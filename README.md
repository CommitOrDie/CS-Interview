- [네트워크](#네트워크)
- [데이터베이스](#데이터베이스)
- [자바](#자바)
- [JPA](#JPA)

# 네트워크
- **쿠키 vs 세션에 대해 설명해주세요**
    - 둘다 HTTP의 stateless한 특성을 보완하기 위해서 나온 기술입니다. 로그인을 유지하는것과 같은 상태유지가 필요할때 사용합니다
    - 쿠키는 저장해야할 데이터가 클라이언트측에 저장되고, 세션은 데이터를 서버측에 저장하고 관리한다는 차이가 있습니다
- **쿠키와 세션의 필요성**
    - HTTP 프로토콜의 경우 “Connectionless, Stateless”한 특성이 있어 요청간에 의존관계가 없습니다.
    - 또한 매 통신마다 새로 연결해야 하기 때문에 현재의 클라이언트가 이전 접속자와 같은지를 알 수 있는 방법이 없습니다. 이 점을 보완하는 데 쿠키와 세션이 사용됩니다.
- 쿠키와 세션의 동작방식
    - **쿠키 동작방식**
        1. 클라이언트가 서버에게 요청을 보냅니다
        2. 서버에서 쿠키를 생성하고 HTTP 헤더에 쿠키를 포함 시켜 응답합니다.
        3. 이제 클라이언트측은 HTTP 헤더에 쿠키를 함께 보냅니다.
    - **세션 동작방식**
        1. 클라이언트가 인증에 성공하면 세션 ID를 발급 받습니다.
        2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있습니다.
        3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청합니다.
        4. 서버는 세션 ID를 전달받아서 세션 Id를 통해 세션저장소(디비)에 있는 클라이언트 정보를 가져와서 사용합니다.
        5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답합니다.
- **쿠키와 세션은 언제 사용하나요?**
    - 쿠키
        - 클라이언트 로컬에 저장되므로 보안에 취약해 로그인같은 인증에는 잘 쓰이지 않습니다.
        - 단순한 **아이디의 저장**이나, **쇼핑몰의 장바구니 담아두기** 같은 기능에 사용합니다.
    - 세션: 보안상 중요한 작업인 **로그인 기능**에 사용됩니다.
- **세션기반 인증방식과 토큰기반 인증방식의 차이 (Token 기반 vs Session 기반)**
    - 두방식의 가장 큰 차이점은, 세션은 데이터베이스 서버에 저장된단는 점,
    - 토큰은 클라이언트 측에서 저장한다는 점입니다.
    - **세션기반인증방식**은, 클라이언트에게 세션 ID를 발급해, 세션 정보를 서버에 저장하여 사용자를 검증하는 방식입니다.
    - **토큰기반방식**은, 따로 정보를 DB에 저장하지 않고 인증된 사용자에게 토큰을 발급하여, 서버에 요청시 토큰을 함께보내고, 이 토큰이 유효하지 확인하여 검증하는 방식입니다.
- **HTTP 프로토콜에 대해 설명해주세요.**
    - HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 규약입니다.
    - HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트와 데이터를 주고받은 뒤 연결을 끊는 Connectionless의 특징을 가지고 있습니다.
    - 장점
        - 상태를 유지하지 않고 해당 요청에 대한 응답만을 내려주면 돼서 서버 디자인이 간단합니다.
    - 단점
        - 이전 통신의 정보를 모르기 때문에 매번 인증정보를 같이 보내줘야 한다.
        - 이를 해결하기 위해 쿠키(cookie)나 세션(session)을 사용해서 데이터를 처리한다.
- stateless, connectionless에 대해 설명해주세요`
    - `connectionless`: 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지 하지 않는 것이다.
    - 이를 통해 서버의 자원을 효율적으로 관리하고, 수 많은 클라이언트의 요청에도 대응할 수 있게 한다
        - 현재는 이 문제를 **HTTP 지속 연결**로 문제를 해결했다.
            - 지속 연결은 요청에 따라 연결이 된 이후 일정 시간 연결을 유지하는것을 말함
    - `stateless`: 서버가 클라이언트의 이전 상태를 보존하지 않는다는 의미이다 (단계별 처리 시 이전 단계의 요청또한 같이 줘야 이해를 할 수 있음)
- http와 https의 차이
    - **HTTP 메시지는 일반 텍스트이므로, 권한이 없는 당사자가 인터넷을 통해 쉽게 액세스하고 읽을 수 있습니다.**
    - **반면, HTTPS는 모든 데이터를 암호화된 형태로 전송해서 쉽게 엑세스할 수 없습니다**
    
- 세션쿠키/지속쿠키 차이점
    - **세션 쿠키**: 만료 날짜/시간을 **지정하지 않으면** 세션 쿠키라고 하는데요 브라우저가 종료되면 쿠키가 사라집니다
    - **지속 쿠키**: 만료 날짜/시간을 **지정하면** 지속 쿠키라고 합니다. 브라우저가 종료되어도 만료날짜에 사라집니다
    
- www.domain.com에 들어가면 어떤 일이 일어나나요?
    1. 사용자가 브라우저에 URL을 입력
    2. DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음
    3. IP 주소로 웹 서버에 TCP 3 handshake로 연결 수립
    4. 클라이언트는 웹 서버로 HTTP 요청 메시지를 보냄
    5. 웹 서버는 HTTP 응답 메시지를 보냄
    6. 도착한 HTTP 응답 메세지가 처리되어 웹 브라우저에 의해 출력
    

- **TCP와 UDP의 차이를 설명해주세요.**
    - **TCP**는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다.
    - **UDP**는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.
    - TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.
    - 3-way handshaking 과정을 통해 연결을 설정하고,
    - 4-way handshaking 과정을 통해 연결을 해제한다.
- OSI-7계층에 대해서 각각 설명해보세요
    - 7 계층(응용 계층) : 우리가 사용하는 응용 서비스나 프로세스가 바로 응용계층에서 동작.
        - http 프로토콜이 응용계층이다
        - 사용자와 가장 가까운 계층이다
    - 6 계층(표현 계층) : 전송하는 **데이터의 표현방식(데이터변환,압축,암호화)**을 결정한다
    - 5 계층(세션 계층) 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
        - **TCP/IP 세션을 만들고 없애는 역할**
    - 4 계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 (단위 :Segment) (ex. TCP, UDP)
    - 3 계층(네트워크 계층) : 패킷을 목적지인 특정 IP까지 가장 빠른 길로 전송하기 위한 계층 (단위 :Packet) (ex. Router)
        - **경로(Route)와 주소(IP)를 정하고 패킷을 전달**해주는 것이 이 계층의 역할이다.
        - 즉, **목적지까지 가장 안전하고 빠르게 데이터를 보내는 기능**을 말한다. 따라서 **최적의 경로를 설정**해야 한다.
        - 이런 라우팅 기능을 맡고 있는 계층이 네트워크 계층이다.
    - 2 계층(데이터링크 계층) :물리계층에서 송수신되는 데이터들의 에러 검출, 흐름 제어를 담당하는 계층 (단위 :frame) (ex. 이더넷)
    - 1 계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층 (단위 :bit) (장비: 케이블,리피터,허브)
        - 단지 데이터를 전달하고 받기만할뿐 오류검출안함
- HTTP METHOD에 대해 설명해주세요
    
    
    | 종류 | 기능 |
    | --- | --- |
    | GET | 데이터 조회 |
    | POST | 요청 데이터 처리(보통 데이터 등록 사용) |
    | PUT | 데이터 변경 (해당 데이터가 없으면 생성) |
    | PATCH | 일부 데이터만 변경 |
    | DELETE | 데이터 삭제 |
- GET과 POST의 차이
    - **GET**은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다. URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다.
    - **POST**는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다. 완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다.
- http only란?
    - **브라우저에서 쿠키에 접근하지 못하게 방지해주는 속성**
- jwt란?
    - json web token
    - JWT는 헤더(Header).내용(Payload).서명(Signature)로 구성되며 각 파트를 점(.)으로 구분합니다.
    - **헤더(Header) :** 토큰 타입과 + 암호화 알고리즘
    - **내용(Payload) :**사용자가 담고자 하는 정보를 담는다. JSON(Key/Value)형태의 한 쌍
    - **서명(Signature) :**토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.
- xss란?
    - 사이트에 접속한 사용자는 악성 스크립트를 실행하게 되며, 보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등 민감한 정보를 탈취한다.
    - 자바스크립트로 쿠키정보를 얻어낼 수 있는데 httponly설정을 주면 이를 막아준다
- jwt를 어떻게 사용해야할까?
    - http only를 사용하자: xss를 예방할 수 있다
    - https를사용하자: 해커들은 쿠키를 탈취하였다고 하여도 암호화가 되어 있어 정보를 알아 낼 수 없습니다
    - refresh token사용을 하는것도 괜찮긴한데… 무제한으로 사용하면 안된다고 한다.. 이건 이유를 모르겠다 무제한으로 사용해야하는거아닌가? refreshtoken의 경우에만 블랙리스트를 도입하는거지.. 그러면 괜찮지않나..?
    
- 대칭키와 비대칭키
    - 대칭키와 비대칭키는**양방향 암호화 방식**
    - **대칭키 :** 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘입니다.
        - 이는 중간에 누군가 암호 키를 가로채면 암호화된 정보가 유출될 수 있다는 단점이 있는데, 이런 문제를 보완한 새로운 방식이 비대칭키(공개키)입니다.
    - **비대칭키**는암호화와 복호화할 때 키를 서로 다른 키로 사용하는 암호화 알고리즘입니다.
        - 타인에게 절대 노출되어서는 안되는 개인키(private key)와 공개적으로 개방되어 있는 공개키(public key)를 쌍으로 이룬 형태입니다.
        
- RSA란?
    - JWT가 쓰는 암호화방식
    - 얘는 public key(공개키), private key(개인키) 두개를 가진다
    - A->B가 message를 보내고싶다
    - 각자 개인키, 공개키를 들고있고, A의 개인키는 A만이 들고있다
        1. A는 일단 B가 만든 B의 공개키로암호화해서 message를 보낸다
        해커가 이 message를 탈취하더라도 열 수 없다. 
            
            B의 공개키로 잠궈진 message는 B의 개인키로만열수있기때문이다
            
            이 방법으로 다음 문제를 해결할 수 있다 `열쇠전달문제`
            
        2. 반대로 이번엔 노출되도 상관없는 정보를 보낸다고가정하자. 단, 이때 누가보냈는지는 알아야한다고 가정하자
            
            그러면 A->B에게 message를 보내는데 자신의 개인키로 암호화를한다. 그러면 B는 A의 공개키로 암호를 풀 수 있다. 그렇기에 B는 A가 보냈음을 확신할 수 있다. 중간에 해커가 채가더라도 중요하지않은 정보이기때문에 채가도 상관없다
            
    - 1번에서 A->B로보내는 message를 해커가 볼 순 없지만 가로채가서 다른것으로 바꿀 순 있다 그래서 이 데이터를 A의 개인키로 한번 더 잠군다
    - B는 문서를 받으면 A의 공개키로 열고, 열리면 인증이 해결되는것이다(A가 보냈음이 확신)
    열리면 자신의(B) 개인키로 열어본다. -> 암호화도 가능한다

- ****Connection Timeout과 Read Timeout의 차이에 대해 설명해주세요****
    - 서버 자체에 클라이언트가 어떤 사유로 접근을 실패했을 시 Connection Timeout
    - 클라이언트쪽은 문제가 없는데 서버측에서 응답에 쓰는 시간이 너무 길어져서 클라이언트가 연결을 해제하는 것이 Read Timeout
- PRIVATE IP VS PUBLIC IP
    - 퍼블릭 IP
        - 인터넷에서 장치를 식별하는데 사용할 수 있는 고유 IP입니다
    - 사설IP
        - 사설IP는 전역적으로 고유 하지 않고 로컬 네트워크 내에서만 엑세스할 수 있습니다
        - 하나의 공유기에 여러 기계가 연결되어있을때 각각의 기계는 사설IP를 사용합니다.
    - 그러니까 만약 라우터 한대에 노트북A와 노트북B가 있다면 노트북A와 B는 공통적인 공용IP(라우터것) 을 사용하고 사설네트워크내에서의 통신이 필요할때면 사설IP를 사용합니다
- **[ TCP와 HTTP 차이 ]**
    - HTTP는 비연결형 프로토콜인 반면에 TCP는 연결형 프로토콜
    - HTTP는 단방향 통신만 가능한 반면에 TCP는 양방향 통신이 가능함
    - HTTP는 응용 계층(7) 프로토콜인 반면에 TCP는 전송 계층(4) 프로토콜
    
# 데이터베이스
- DBMS를 정의하십시오.
    - 데이터베이스: 정보의 모음
    - 데이터베이스관리시스템: 데이터베이스와 사용자를 연결시켜주는 sw.
        - 말그대로 DB를 관리하기 쉽게 도와주는 SW
- RDBMS를 정의하십시오.
    - 관계형 데이터베이스를 관리하는 프로그램
    - 관계형 데이터베이스:  **구조화된 테이블로 데이터를 구성하는 디비 종류중 하나**
- 데이터베이스에서 다양한 유형의 관계는 무엇입니까??
    
    **답변 :** 데이터베이스에는 3 가지 유형의 관계가 있습니다.
    
    - **일대일 :** **`1:1 관계`**란 어느 엔티티 쪽에서 **상대 엔티티와 반드시 단 하나의 관계를 가지는 것**을 말한다. 예를 들어, 우리나라에서 결혼 제도는 일부일처제로, 한 남자는 한 여자와, 한 여자는 한 남자와 밖에 결혼을 할 수 없다. 남편 또는 부인을 2명 이상 둘 수 없는데, 이러한 관계가 `1:1 관계`다.
    - **일대다 :** 한쪽엔티티가 다른쪽 엔티티 여러개와 관계를 맺는 상황. 예를들면 하나의 팀에 여러 멤버가 속할 수 있는상황
    - **다대다 :** 관계를 가진 **양쪽 엔티티 모두에서 `1:N 관계`를 가지는 것**을 말한다.
    즉, **서로가 서로를 `1:N 관계`로 보고 있는 것**이다. 가령 학생은 여러 수업을 들을 수 있고 하나의 수업에 여러 학생이 있을 수 있는 상황을 말합니다
- 데이터베이스 언어(SQL)에 대해 설명하세요.
    
    **답변 :** SQL 문은 기본적으로 DDL, DML 및 DCL의 세 가지 범주로 나뉩니다.
    
    **DDL (데이터 정의 언어)** : 테이블 객체의 생성, 변경, 삭제 명령어를 뜻합니다. 예를 들어, create, alter, drop, rename 등이 있습니다. schema, domain, table, view, index를 정의, 변경, 삭제할 때 사용하는 언어입니다. → 데이터 구조를 정의하는 명령어
    
    **DML (데이터 조작 언어) 레코드 제어 명령어 입니다. 예를 들어, select, insert, update, delete 등이 있습니다.**
    
    **DCL (데이터 제어 언어)** ; 권한을 제어하는 언어로 사용자 권한을 제한 하거나 할때 사용함
    
- 정규화와 비정규화를 설명하십시오.
    - **정규화: 데이터베이스에서 중복을 제거해서 구조화하는 과정**
    - **비정규화: SQL성능을 높이기 위해서 일부러 정규화를 깨는 과정**
- 정규화의 장점/단점
    - 장점: 중복제거로 용량 확보
    - 단점: JOIN연산이 많아질 수 있씁니다
- 데이터베이스 뷰란?
    - **원하는 데이터만 뽑아서 보여주기 위해 하나 이상의 테이블에서 유도된 가상 테이블**입니다.
    1. 쿼리의 복잡성을 단순화할 수 있다
    2. 뷰는 sql문을 저장하는거다 sql문의 결과가아니라. 만약 자주 재사용되는 sql문이 있다면 뷰를 사용해서 sql문을 재사용할 수 있다. 메서드같이 말이다. 수정포인트가 한곳으로 줄어드니 효율적이다
    3. 보안기능을 적용할때도 뷰가 효과적이다 . 예를들어 학생과 교사 의 권한에 따라 학생id를 교사한텐 안보여줘야한다면.. 교사뷰와 학생뷰를 따로 만들어서 sql쿼리 단계라는 가장 깊은 단계에서부터 데이터가 감춰진 채로 반환이된다. 이는 좋은 보안성을 제공해준다
        - service단에서 학생id를 —-로 제공할수도있으나 항상 우리는 오류의 가능성을 포함해야한다. 애초부터 학생id를 제공하지 않는 뷰를 사용하면 보안상 더 좋다

- ER 모델은 무엇입니까?
    - Entity-Relationship Model(다이어그램)
    - 데이터베이스 설계에 사용되는 테이블을 시각화한 도구입니다
- 데이터베이스 트랜잭션이란 무엇입니까?
    - 데이터베이스의 작업단위입니다
    - 트랜잭션 도중에 실패하면 롤백되고 모두 성공해야만 커밋이 됩니다
        - 롤백은 트랜잭션 시행 이전으로 돌아가는것을 말하며
        - 커밋은 변경사항이 실제 디비에 반영되는것을 말합니다
- 인덱스란?/언제사용해야하나요?
    - 책의 목차와 같은 sql 속도를 높여줄 수 있는 자료구조 입니다
    - 인덱스는 인덱스 컬럼을 도입해서 빠르게 데이터를 추출할 수 있을때 사용합니다 보통 많은 데이터에서 소량만 추출할 경우 사용하죠
        - 많은 데이터에서 많은 데이터를 추출하는 경우엔 불리해요
        - 왜냐면 인덱스를 사용할경우 index range scan을 쓰게 되는데 이게 디스크 블록읽을때 조금씩 가져옴 그래서 많은 데이터를 추출해야할때 비요율이 발생한다
- 기본 키(Primary key)와 복합 키(Compound key)를 설명하십시오.
    - **기본 키** : 레코드 고유 식별 컬럼
    - 기본키와 복합키는 둘다 레코드를 유일하게 식별할수있는 컬럼인데그게 1개면 기본키고 2개이상이면 복합키
- Unique 키가뭐임?
    - Unique키: 유일성을 가지는 컬럼
    - 여러개 생성가능/NULL가능
- 디비 트리거가 뭐임  + + 왜 사용함?
    - 테이블에서 삽입 전, 삽입 후, 업데이트시, 행 삭제시와 같은 **이벤트가 발생할 때 자동으로 실행되는 명령 세트**를 데이터베이스 트리거라고합니다.
    - 업무 처리 자동화 / 무결성 강화에도 도움
- 'DELETE', 'TRUNCATE' 'DROP'의 차이는?
    - DELETE는 한 번에 한 행씩 테이블에서 특정 행을 제거하는 데 사용됩니다.
        - 큰 테이블의 경우 레코드를 개별적으로 제거하고 각 삭제를 기록하기 때문에 시간이 걸릴 수 있지만 WHERE 절을 사용하여 제거할 레코드를 선택할 수 있습니다
        - 테이블 데이터 삭제 (로그 o, 삭제조건설정가능, 느림).
    - **TRUNCATE:** 테이블에서 모든 레코드를 신속하게 제거하지만 유지할 레코드를 지정할 수는 없습니다. 또한 개별 행 삭제를 기록하지 않으므로 더 빠릅니다.
        - 테이블에서 모든 행이 제거됩니다. 그러나 테이블의 구조, 열, 제약 조건, 인덱스 등은 그대로 유지됩니다. 단순히 데이터 테이블을 비우는 것입니다.
        - 테이블 데이터 삭제 (로그 X, 삭제조건설정불가, 빠름)
    - DROP: DROP은 상자와 함께 피자를 통째로 버리는 것과 같습니다. 피자와 용기가 모두 사라졌습니다. 마찬가지로 데이터베이스에서 DROP은 데이터와 구조를 포함하여 전체 테이블을 제거합니다. 테이블이 존재하지 않는 것과 같습니다.
        - 테이블 자체 삭제
- 이상현상이란?/ 이상의 종류는?
    - 데이터베이스에서 정규화를 수행하지 않으면, 데이터의 중복이 발생하고 전체적인 무결성(정확성)이 저하됩니다. 이러한 원인은 데이터 **이상 현상(Anomaly)**에 의해 발생하며, 이상 현상으로 인해  현실세계의 실제 값과 데이터베이스에 저장된 값이 일치하지 않는 문제가 발생합니다..
    - → 즉, 이상현상: 디비 정규화를 제대로 수행하지 않으면 겪을 수 있는 여러 문제 상황
    - 다음은 이상 현상을 설명할 대학교 테이블입니다.
    
    | 학번 | 학생명 | 학과 코드 | 학과명 | 학과장 코드 | 학과장명 |
    | --- | --- | --- | --- | --- | --- |
    | 1 | 도우너 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | 2 | 고길동 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | 3 | 또치 | 102 | 물리학과 | 2000 | 아인슈타인 |
    | 4 | 마이콜 | 102 | 물리학과 | 2000 | 아인슈타인 |
    | 5 | 둘리 | 103 | 컴퓨터공학과 | 3000 | 빌 게이츠 |
    
    ---
    
    ### **삽입 이상(Insertion anomaly)**
    
    - **삽입 이상**은 특정 데이터가 존재하지 않아 중요한 데이터를 데이터베이스에 삽입할 수 없을 때 발생합니다.
    - 대학교 테이블에서 기본키는 '학번'입니다. 새로운 행을 삽입하기 위해서는 기본키인 '학번'이 필수입니다.
    - 현재 3개의 학과(경영학과, 물리학과, 컴퓨터공학과)가 존재하고 신설학과인 '수학과'가 새로 생겼으며, 대학교 테이블에 데이터를 추가해야 합니다.
    
    !https://blog.kakaocdn.net/dn/cpMjgF/btrmoqwcdRP/3KxplydxU6AQDVaUzyQaSk/img.png
    
    - 하지만, 신설학과인 '수학과'에는 학생이 존재하지 않기 때문에 대학교 테이블에 데이터를 추가할 수 없습니다.
    - 이러한 현상을 **삽입 이상**이라고 합니다.
    - 물론, 정규화에 의해 대학교 테이블을 학생 테이블, 학과 테이블로 분리한다면 데이터를 추가할 수 있지만, 설명하고 있는 예시는 정규화가 되지 않은 상태라고 가정합니다.
    - → 당연히 삽입이 돼야하는데 안되는 상황(정규화가 제대로되지않아서 문제발생)
    
    ---
    
    ### **삭제 이상(Deletion anomaly)**
    
    - **삭제 이상**은 특정 정보를 삭제하면, 원치 않는 정보도 삭제되는 현상입니다.
    - 컴퓨터공학과의 둘리 학생이 자퇴해서 데이터를 삭제해야 하는 경우 컴퓨터공학과의 학과 코드 및 학과장 정보도 삭제됩니다.
    
    !https://blog.kakaocdn.net/dn/ybtso/btrmoqwcn0M/J1CenPLzallpiHHhjD3Lok/img.png
    
    - 둘리 학생의 데이터를 삭제하면, 컴퓨터공학과의 학과 코드와 학과장 정보를 특정 테이블에 저장하지 않았기에 데이터가 소멸되는 문제가 발생합니다.
    - 이러한 현상을 **삭제 이상**이라고 합니다.
    - 삽입 현상에서 설명했듯이 정규화에 의해 테이블을 분리하면 삭제 이상을 해결할 수 있습니다.
    
    ---
    
    ### **업데이트 이상(Update anomaly)**
    
    - 테이블의 특정 데이터를 업데이트했는데, 정상적으로 변경되지 않은 경우 그리고 너무 많은 행을 업데이트하는 것을 **업데이트 이상**이라고 합니다.
    - 경영학과의 학생이 100명이라고 가정하고 경영학과의 학과장이 이름을 개명해서 학과장명을 변경해야 하는 경우입니다.
    
    | 학번 | 학생명 | 학과 코드 | 학과명 | 학과장 코드 | 학과장명 |
    | --- | --- | --- | --- | --- | --- |
    | 1 | 도우너 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | 2 | 고길동 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | ... | ... | ... | ... | ... | ... |
    | 100 | 둘리 | 101 | 경영학과 | 1000 | 워런 버핏 |
    - 경영학과의 학생이 100명이므로 100개의 데이터를 변경해야 합니다.
    여기서 변경되지 않은 행이 한 개라도 존재하면, 데이터가 상이한 문제가 발생합니다.
    - 그리고 학생이 1000명이라면, 1000개의 데이터를 변경해야 하는 비효율적인 문제가 발생합니다. 이러한 현상을 **업데이트 이상**이라고 합니다.
- 데이터베이스 무결성이란?
    - 데이터의 정확성과 일관성을 유지하고 보증하는 것을 의미한다
    - **개체 무결성**
        - 서로 다른 두 튜플은 같을 수 없음.
        - 기본키는 NULL값이나 중복값을 가질 수 없다.
    - **참조 무결성**
        - 관련된 테이블의 레코드 간의 관계를 유효하게 하는 규칙
        - 외래키는 항상 NULL이거나 참조 테이블의 기본키 값이어야함
- 조인에 대해 설명하고 조인의 종류에 대해 말하세요.
    - 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법입니다.
    - **Inner Join** 은 2개 이상의 테이블에서 교집합만을 추출
    - **Left Join** 은 2개 이상의 테이블에서 from에 해당하는 부분을 추출
    - **Right Join** 은 2개 이상의 테이블에서 join하는 테이블에 해당하는 부분을 추출
    - **Outer Join** 은 아웃터 조인 또는 풀 조인이라고 말함, 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출 (합집합)

- 교착상태란? / 방지하려면?
    - 2개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 **교착상태** 라고 합니다.
    - 두개의 트랜잭션 작업이 서로 완료 될 때 까지 기다리게 되며 결과적으로 아무것도 완료가 되지 않는 상태
    
    <<방지법>>
    
    - 트랜잭션을 자주 커밋한다.
        1. 트랜잭션 A는 테이블 1의 행을 업데이트한 다음 테이블 2의 행을 업데이트하려고 시도합니다.
        2. 트랜잭션 B는 테이블 2에서 동일한 행을 업데이트한 다음 트랜잭션 A가 업데이트한 테이블 1에서 동일한 행을 업데이트하려고 시도합니다.
        
        이제 트랜잭션 A는 트랜잭션 B가 테이블 2의 잠금을 해제하기를 기다리고 있고 트랜잭션 B는 트랜잭션 A가 테이블 1의 잠금을 해제하기를 기다리고 있기 때문에 교착 상태에 빠졌습니다. 둘 다 진행할 수 없으며 교착 상태가 발생합니다.
        
        그러나 트랜잭션 A가 테이블 1을 업데이트한 직후, 테이블 2를 업데이트하려고 시도하기 전에 트랜잭션 A를 커밋한다고 가정해 보겠습니다. 이제 테이블 1에 대한 변경 사항이 저장되고 테이블 1에 대한 잠금이 해제됩니다. 이제 트랜잭션 B가 테이블 1을 업데이트하려고 하면 더 이상 트랜잭션 A에 의해 잠기지 않고 대기 없이 진행할 수 있습니다.
        
        - 자주 커밋하면 LOCK이 빨리 해제되니까 해결되는듯
    - 정해진 순서로 테이블에 접근한다
        - 프로세스 A는 리소스 1을 잠그고 리소스 2를 필요로 합니다.
        - 프로세스 B는 리소스 2를 잠그고 리소스 1이 필요합니다.
        - 항상 리소스 2보다 먼저 리소스 1을 잠그는 것과 같이 항상 특정 순서로 리소스를 잠그면 이러한 상황을 피할 수 있습니다. 그 이유는 실행할 두 번째 프로세스가 자원 1을 잠그기 전에는 자원 2를 잠글 수 없기 때문입니다(첫 번째 프로세스가 이미 잠근 상태이므로).
- NoSQL이 기존 RDBMS와 다른 점은?
    - **NoSQL** 은 스키마가 없습니다. 즉 데이터 관계와 정해진 규격(table-column의 정의)이 없습니다.
    - 관계 정의가 없으니 Join이 불가능하고 트랜잭션을 지원하지 않습니다.
    - 분산처리(수평적 확장)의 기능을 쉽게 제공한다는 장점이 있습니다.
- ****SELECT 쿼리의 수행 순서를 알려주세요.****
    
    *FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT*
    
- 디비 락에 대해 설명해주세요
    - lock은 어떠한 충돌하는작업(동시에 하나의 데이터를 수정한다든가)을 막기위한 개념
    - DB Lock은 작업이 완료될 때까지 다른 트랜잭션이 현재 작업 중인 데이터를 변경할 수 없도록 하는 "방해 금지" 표시와 같다
    - **공유락**(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다.
    - **베타락**(LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.
- Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
    - RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
    - 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 역색인을 지원해서 매우 빠르다는 특징을 가짐
- 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.
    - 옵티마이저는 SQL을 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
- DB 튜닝(Tuning)이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요.
    - DB 튜닝이란 DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말합니다.
    - 튜닝은 DB 설계 튜닝 → DBMS 튜닝 → SQL 튜닝 단계로 진행할 수 있습니다.
    - 1단계 - DB 설계 튜닝(모델링 관점)
        - DB 설계 단계에서 성능을 고려하여 설계
        - **튜닝 사례** - 반정규화, 분산파일배치
    - 2단계 - DBMS 튜닝(환경 관점)
        - **튜닝 사례** - Buffer 크기, Cache 크기
    - 3단계 - SQL 튜닝(App 관점)
        - SQL 작성 시 성능 고려
        - **튜닝 사례** - Hash / Join
- 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요.
    - Replication은 말 그대로 복제라는 의미다. 여기서는 데이터베이스 스토리지를 복제하는 것을 의미한다.
    - Clustering은 단순히 데이터베이스 서버를 확장한 것이라면 Replication은 데이터베이스 서버와 스토리지 모두를 확장하게 된다.
    - 클러스터링 (동기)
        - 디비 서버가 늘어나는게 클러스터링이다. 부하가 분산되니 CPU와 Memory도 부하가 줄어들게 된다.
        - 서버하나가 죽더라도 다른 서버로 서비스를 제공할 수 있다 ( 고가용성 )
    - 리플리케이션 (비동기)
        - 데이터변경은 master에게 데이터 조회는 slave가 처리한다
        - Master에서 Slave로 비동기 방식으로 데이터를 동기화 하기 때문에 일관성있는 데이터를 얻지 못할 수 있다.
        - 동기방식으로 Replication을 할 수 있지만 이럴 경우 속도가 느려진다는 문제점이 있다.
        - Master 서버가 다운이 될경우 복구 및 대처가 까다롭다는 단점이 있다.
- JOIN에서 ON과 WHERE의 차이를 설명해주세요.
    - **ON**이**WHERE**보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코들간 JOIN이 이뤄진다)
    - WHERE은 JOIN 을 한 후에 필터링을 합니다. (=JOIN을 한 결과에서 WHERE 조건절로 필터링이 이뤄진다)
- 디비에서 동기/비동기의 차이를 블럭/논블럭과 함께 설명하세요
    
    동기: 요청-결과가 동시에 일어난다는 것 (이때 답을 받을때까지 아무것도 할 수 없어서 블록 상태가 됨)
    
    비동기: 요청-결과가 동시에 일어나지않음 (답을 받을때까지 이것저것 할 수 있다. 논블럭상태라고 한다)
    
- 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요
    - 데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.
    - 일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.
    - 일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다. 또한 인덱스를 저장하기 위한 공간이 추가적으로 필요합니다
    - Index는 데이터베이스 테이블의 검색 속도를 향상해주기 위한 자료구조입니다.
    일반적으로 Index에 비유되는 예가 책의 색인 혹은 목차입니다.
    Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성할 수도 있습니다
- ACID에 대해서 설명해주세요.
    - 트랜잭션이 안전하게 수행됨을 보장하기 위한 성질을 가리키는 약어
    - Atomicity(원자성)
        - 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션 내의 모든 연산은 실패해야 합니다.
    - Consistency(일관성)
        - 트랜잭션은 유효한 상태로만 변경될 수 있습니다.(제약조건을 만족시키는 한에서 변경이 가능함을 의미)
    - Isolation(고립성)
        - 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
    - Durability(내구성)
        - 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)
- 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
    - READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.(잘안사용)
    - READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다.
    - REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.
    - SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.
    (성능 매우 떨어짐)
- 정규화에 대해서 설명해주세요.
    - 중복된 데이터를 최소화하게 데이터를 구조화하는 과정을 말합니다
    - DB의 저장 용량줄일 수 있다
- 제1정규화, 제 2정규화, 제 3정규화, BCNF 정규화 설명
    - 제1정규화
    - 컬럼이 하나의 값만 갖도록

    - 제 2정규화
        - 제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.
        - 여기서 완전 함수 종속이라는 것은 기본키의 일부가 결정자이면 안됩니다.
        - 예를들어 성적을 결정하기 위해선 [학번, 과목코드]가 모두 필요하다. 둘 중 하나만으로는 어떤과목에 대한 학생의 성적을 결정할 수 없다. 그러므로  성적은 [학번, 과목코드]에 ***완전 함수적 종속***이다. < 즉, 어떤 요소를 결정하는데 기본키의 일부만 쓰인다면 완전함수적 종속을 만족하지 않는것이라고 할 수 있습니다.
        - 기본키: 테이블 row의 고유 식별자
        - X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때,
        **Y는 X에 함수적 종속**이라고 합니다. 
        이 경우 **X를 결정자**, **Y를 종속자**라고 합니다. 
        **X→Y**
        
        !https://blog.kakaocdn.net/dn/ylbaZ/btqT8Jc4K3s/0VFTPoKKFkbxZghKWDwKo1/img.png
        
        - 이 테이블에서 기본키는 (학생번호, 강좌이름)으로 복합키이다. 그리고 (학생번호, 강좌이름)인 기본키는 성적을 결정하고 있다. (학생번호, 강좌이름) --> (성적)
        - 그런데 여기서 강의실이라는 컬럼은 기본키의 부분집합인 강좌이름에 의해 결정될 수 있다. (강좌이름) --> (강의실)
        - 즉, 기본키(학생번호, 강좌이름)의 부분키인 강좌이름이 결정자이기 때문에 위의 테이블의 경우 다음과 같이 기존의 테이블에서 강의실을 분해하여 별도의 테이블로 관리하여 제2 정규형을 만족시킬 수 있다
            
            !https://blog.kakaocdn.net/dn/bluCnc/btqT7VEOf04/Me8DfY7rtycgJPYlYQKEWK/img.png
            
    - 제 3정규화
        - 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
        - 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다.
            
        - 기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다.
        - b의 변경이 c의 변경또한 이루어져야하는데 이를 수동으로 처리해주어야한다. 이 불편함때문에 이행적 종속을 없애는것이다.
        - 이행적 종속을 제거하는 이유는 비교적 간단하다. 예를 들어 501번 학생이 수강하는 강좌가 스포츠경영학으로 변경되었다고 하자. 이행적 종속이 존재한다면 501번의 학생은 스포츠경영학이라는 수업을 20000원이라는 수강료로 듣게 된다. 물론 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것이다.
    - BCNF 정규화
        - 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
        - 후보키: 튜플을 **유일하게 식별할 수 있는 속성, 기본키로 선택될 수 있는 후보들을 의미**
        
        - 특강수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키 (학생번호, 특강이름)는 교수를 결정하고 있다. 또한 여기서 교수는 특강이름을 결정하고 있다.
        - 그런데 문제는 교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니라는 점이다. 그렇기 때문에 BCNF 정규화를 만족시키기 위해서 위의 테이블을 분해해야 하는데, 다음과 같이 특강신청 테이블과 특강교수 테이블로 분해할 수 있다.
            
- JOIN정의, 조인알고리즘 종류 대해 설명하세요
    - **조인이란 두 개 이상의 테이블을 하나의 집합으로 만드는 연산**이다
    - 조인알고리즘 종류
        - Nested Loops Join(중첩 루프 조인)
            - 한 테이블의 각 행을 반복하고 다른 테이블의 해당 행과 일치시키는 방식으로 작동합니다.
        - Merge Join(병합 조인)
            - 두 테이블을 각각 조건에 맞게 먼저 읽는다.
            - 그리고 읽은 두 테이블을 조인 컬럼을 기준으로 정렬해놓고, 조인을 수행한다.
        - Hash Join(해쉬 조인)
            - **테이블 중 하나를 해시 테이블로 선정**하여 조인될 테이블의 조인 키 값을 **해시 알고리즘**으로 비교하여 매치되는 결과값을 얻는 방식
- 낙관적락과 비관적락의 차이
    - 낙관적락은 충돌이 발생하지 않을거라고 가정하고 작업을 진행하는걸 말하구요(트랜잭션 커밋시에 충돌을 알게됨)
    - 비관적 락은 충돌이 발생할것으로 가정하고 일단 락을 걸고 보는 방식이다

- 클러스터 인덱스 vs 논클러스터인덱스
    - 클러스터 인덱스
        - 물리적으로 정렬된 상태
        - 기본적으로 대부분의 dbms에서는 pk를 가지고 클러스터 인덱스를 만듦
    - 논클러스터인덱스
        - 데이터는 정렬되지 않았지만 데이터를 참조하는 페이지가 정렬되어있다고 보면 됨
    
    → 클러스터 인덱스는 데이터 위치를 바로 알기 때문에 그 데이터로 바로 접근할 수 있고, 넌 클러스터 인덱스는 인덱스 페이지를 한번 거쳐서 데이터에 접근하는 방식이다.
    
- **테이블 파티셔닝이란?**
    - table을 파티션이라는 단위로 나누어 관리하는 기법
    - 파티셔닝을 언제사용할까?
        1. **대형 테이블**: 테이블이 매우 큰 경우 쿼리 속도가 느려질 수 있습니다. 파티셔닝은 데이터베이스 시스템이 전체 테이블이 아닌 관련 파티션만 스캔하도록 하여 성능을 향상시키는 데 도움이 될 수 있습니다.
        2. **빈번한 대량 로드 및 삭제**: 예를들어 날짜별로 테이블을 파티셔닝하고 날짜별로 날리고 추가하는 경우에 편함
        3. 
    
    파티셔닝은 일반적으로 DB 테이블을 작은 부분으로 여러 개 나누는 것을 의미합니다.
    
    파티셔닝은 열에 대해서 수직으로 혹은 행에 대해 수평으로 나누는 두 가지 방법이 존재합니다.
    
    - 종류
        - 수평 파티셔닝
            - 하나의 테이블안에있는 데이터를 두개의 테이블로 나눠 저장하는 방법
            - “샤딩”이라고도 불린다
            - 샤딩은 각 DB 서버에서 데이터를 분할하여 저장하는 방식이다. 해당 데이터에 접근할 때는 샤딩키를 사용하여 동적으로 DB 서버를 매핑하는 과정이 필요하다.
            - 샤딩은 일반적으로 DBMS가 지원하는 기능이 아니다. 그래서 ORM을 사용하거나 DB에 접근하는 서버에서 구현해주는 작업이 필요하다.
        - 수평 파티셔닝의 장점
            - DB 트래픽을 분산할 수 있는 중요한 수단이다.
            - 특정 DB의 장애가 전면 장애로 이어지지 않게 하는 역할도 한다.
        - 수평 파티셔닝의 단점
            - 샤딩은 실제 구현이 복잡하다. 잘못 수행하면 **데이터가 손실되거나 테이블이 손상되거나 부하의 불균형** 등이 발생할 수 있다. 이를 **샤딩 전 원래 DB 구조로 되돌리는 작업은 매우 복잡**하고 어렵다.
        - 수직 파티셔닝
            - 테이블의 일부열을 빼내는 형태로 구현
        - 수직파티셔닝의 장점
            - 자주 사용하는 컬럼 등을 분리시켜 성능을 향상시킬 수 있다.
            - 한 테이블을 SELECT하면 결국 모든 컬럼을 메모리에 올리게 되므로 필요없는 컬럼까지 올라가서 한 번에 읽을 수 있는 ROW가 줄어든다. 
            이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.
- RDBMS vs NOSQL에 대해서 설명해주세요.
    - RDBMS(Relational Database Management System)
        - 데이터를 컬럼과 로우의 형태로 저장합니다.
        - 구조화 되어있기때문에 sql을 활용하여 질의가능
    - NOSQL(not only sql)
        - 자유로운 데이터 구조를 가질 수 있습니다
        - 데이터가 Key와 Value의 쌍으로 저장된다.
        - RDBMS에 비해 복잡도가 떨어져 많은 데이터 저장
        - NoSQL은 이름처럼 ***SQL***을 사용하지 않고 별도로 제공하는 API를 통해 데이터를 건들 수 있다
        - RDBMS는 관계형 데이터베이스 관리 시스템을 의미합니다.
        관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스입니다.
        - 또한 RDBMS는 관계를 맺고 모여있는 테이블들의 집합체로 이해할 수 있습니다.
        이러한 테이블 간의 관계에서 서로의 칼럼을 기준으로 Join이 가능하다는 게 RDBMS의 가장 큰 특징입니다.
        - NoSQL이란(Not Only SQL)의 비 관계형 데이터베이스로서 약자로 말 그대도 위에서 설명한 RDB 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하고 있습니다.
        - **NoSQL에서는 RDBMS와는 달리 테이블 간 관계를 정의하지 않습니다. 관계 정의가 없으니 Join이 불가능하고 트랜잭션을 지원하지 않습니다.**
        - NoSQL은 데이터와 트래픽이 너무 클때 스케일업대신 선택할 수 있습니다.(비용문제측면에서) 대신.. 데이터 일관성은 포기하되 비용을 고려하여 여러 대의 데이터에 분산하여 저장하는 Scale-Out을 목표로 등장하였습니다.
    - nosql이 scale out하기에 좋게 설계되었다면서.. 어떤 설계가 scale out하기 좋은 설계지?
        - NoSQL 데이터베이스는 처음부터 데이터가 여러 서버 또는 노드에 분산될 수 있는 분산 시스템에서 작동하도록 설계되었고 여러 기능을 지원함
    - ㄴㄴ
    
    * 사전 지식
    
    - Scale-Up : 하드웨어를 변경하여 시스템의 성능을 높임
    => 비용이 많이 발생
    - Scale-Out : 하나의 장비에서 처리하던 일을 여러 장비에 나눠서 처리함 => 비교적 저렴한 방식으로 서버 유지 가능
- Redis에 대해서 간단히 설명해주세요.
    - "key-value" 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터베이스 (nosql) 관리 시스템이다.
- Redis와 Memcached의 차이에 대해서 설명해주세요.
    - 둘다 “key-value" 구조의 비정형 데이터를 저장하고 관리하기 위한 비관계형 데이터베이스 관리 시스템 입니다
    - Redis는 다양한 자료구조(리스트 등)를 지원하고, Memcached는 문자열 형태로만 저장합니다.
    - Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원합니다
    - 둘다 인메모리 저장소여서 컴퓨터가 꺼지거나하면 데이터가 날라갈 위험이 있다. 하지만 레디스는 디스크에 데이터를 백업해주는 기능이 추가로 있어서 데이터 유실의 걱정이 적다
- Elastic Search에 대해서 간단히 설명해주세요.
    - Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다
    - 방대한 양의 데이터를 신속하게 저장, 검색, 분석할 수 있습니다.
    - RDBS에서 인덱싱을 활용하면 검색성능을 향상시킬 수 있듯이 엘라스틱 서치는 이러한 인덱싱에 특화되어있습니다.
- MongoDB에 대해서 간단히 설명해주세요.
    - **JSON 개체와 유사한 document를 사용하여 데이터를 저장합니다**
    - 여기서 document란 key-value 쌍으로 이루어진 데이터 구조를 말합니다
    - RDB에 있는 조인을 비슷하게 흉내낼 수 있다
- 커넥션풀이란?
    - 디비와 연결을 하려면 커넥션을 얻어야한다
    - 커넥션 풀이란 DB와 미리 연결해놓은 connection들을 pool에 저장해두고,
    - 클라이언트 요청이 오면 connection을 빌려주었다가 사용이 끝나면 반납하는 방식을 의미합니다. DB connection이 많은 시간이 소요되고 불필요한 connection 연결과 해제를 할 필요가 없어 성능 상의 이점이 있습니다.
- sqlmapper vs orm
    1. SQL Mapper
        
        object와 sql문을 매핑하는 기술
        
    2. ORM
        
        Object와 DB테이블을 매핑하여 데이터를 객체화하는 기술
        
- jpql vs sql
    - JPQL엔티티 객체를 대상으로 쿼리한다.SQL은 데이터베이스 테이블을 대상으로 쿼리한다.
- **em.flush란?**
    - 영속성 컨텍스트의 변경 내용을 DB 에 반영하는 것을 말한다.
    - 이것을 해도 1차캐시의 내용은 비워지지 않는다
    - 1차 캐시의 내용을 비우는 em.clear()가 필요하다
- Persistence Framework란?
    - 데이터를 가공하는 자바 <-> 데이터를 저장하는 디비 층을 연결해주는 매개체
    - sql mapper와 orm이있다.
- 인덱스의 자료구조에는 어떤것들이 있나요?
    - 인덱스의 구현을 위해서는 대표적으로 B+트리와 해쉬테이블이 이용됩니다.
    - 해쉬 테이블은 (데이터, 데이터의 위치)를 (key, value)로 하여 해시를 생성합니다.
    - B+ 트리는 범위 쿼리 및 정렬된 데이터에 효율적입니다. 해시 테이블은 특정 데이터 조각을 찾는 데 매우 빠르지만 순서를 유지하지 않으며 범위 쿼리에 효율적이지 않습니다
- Table Full Scan과 Index Range Scan의 차이
    - 전자는 조건에 만족하는 데이터를 찾기위해 모든 row를 스캔해야한다면
    - 후자는 조건에 만족하는 데이터를 인덱스에 의해 정렬되어있어서 빠르게 찾을 수가 있어
- SQL injection이란?
    - 해커에 의해 조작된 쿼리문이 DB에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법입니다.
    - 주로 사용자가 입력한 데이터를 제대로 필터링하지 못했을 경우에 발생합니다.
    - HTTP1: 각요청에 대해 새 연결을 열어서 비효율적일 수 있습니다
    요청과 응답을 순서대로 하나씩 처리합니다. 하나의 요청이 막히면 그 뒤의 모든것들이 기다려야합니다
    - HTTP2: 여러 요청에 대해 하나의 연결만 사용하여 여러 요청과 응답을 병렬로 보냅니다.
    여러 요청과 응답을 동시에 처리하니까 하나가 막히더라도 다른 요청을 진행해서 효율적입니다.


# 자바
- **JVM이란 무엇인가?**
    - 자바가상머신을 부르는 말
    - 자바 애플리케이션을 실행하는 가상컴퓨터같은 개념입니다.
    - JVM이 있는 모든 시스템에서 자바코드를 실행중인 CPU가 이해할수있도록 해석해줍니다
- JVM이 하는일
    - 소스 코드는 바이트 코드로 컴파일이 되는데 JVM은 런타임 시 이 바이트 코드를 특정 OS에 맞게 조정된 기계어로 해석해줍니다
    - 메모리할당 및 가비지 컬렉터 작업을 수행합니다. 더이상안사용되는 것들을 메모리에서 지웁니다
- JAVA와 C의 차이
    - C언어를 예로 들어봅시다 .C로 된 파일이 있다면 OS마다 다른 컴파일러가 존재하고 그에 따라 다른 실행파일이 만들어집니다. 이 다른 실행파일들은 서로 다른 OS에서만 실행될 수 있습니다. 즉, 컴파일한 파일, 실행파일만 가지고는 서로 다른 OS에서 실행시킬 수 없다는 의미입니다. .C 파일을 받아서 새로 컴파일하고 새로 실행파일을 만들어주어야합니다하지만 JAVA는 하나의 .JAVA파일을 컴파일한 .CLASS파일을 어느 OS에서든 실행시킬 수 있죠
    - JAVA는 OS에 종속적이지 않습니다. 어느 JVM에서나 동작시킬 수 있죠하지만 JVM은 OS에 종속적입니다. 리눅스에서깔수있는 JVM이 있고, 윈도우에 맞는 JVM이 있죠
- jvm의 동작방식
    1. 운영체제로부터 메모리를 할당받습니다
    2. 자바 컴파일러가 .JAVA->.CLASS(바이트코드)로 컴파일합니다
    3. Class Loader가 1번에서 할당받은 메모리중 일부 영역에 Runtime Data Area로 클래스를 로딩한다.클래스가 가지고 있는 여러 부분들을 적당한 영역에 배치한다
    4. 로딩된 .class들은 실행엔진을 통해 해석된다
- **OOP(Object Oriented Programming) 란?**
    - 프로그래밍에서 필요한 데이터를 추상화시켜 행위(Method)와 상태(Attribute)를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
    - OOP의 4가지 특징(캡 상추다)으로는 캡슐화, 상속, 추상화, 다형성이 있다.
- OOP의 특징 4가지
    - 캡상추다
    - 캡슐화: 객체의 속성과 행위를 클래스 안에 넣고, 실제 구현 내용 일부를 내부에 감추어 은닉
    - 상속: 상위개념이 가지고 있는 변수, 메서드를 하위 개념이 물려받는것
    - 추상화: 객체들의 공통적인 특징(속성,기능)을 모아 하나의 클래스로 다루는것
    - 다형성: 하나의 타입으로 여러가지 참조변수를 사용할 수 있는 것
- 추상(abstract) 메서드 , 추상클래스에 대해 설명해주세요
    - **추상메서드** : 자식클래스에서 반드시 오버라이딩 해야하는 메서드
    - **추상클래스** : 하나 이상의 추상 메소드를 포함하는 클래스
        - 추상 클래스는 동작이 정의되어 있지 않은 추상 메소드를 포함하고 있으므로, 인스턴스를 생성할 수 없습니다. 추상 클래스는 먼저 상속을 통해 자식 클래스를 만들고, 만든 자식 클래스에서 추상 클래스의 모든 추상 메소드를 오버라이딩하고 나서야 비로소 자식 클래스의 인스턴스를 생성할 수 있게 됩니다.
- **instanceof 연산자는?**
    - 형변환이 가능한지 불가능한지 여부를 boolean으로 알려줍니다
- 인터페이스가 무엇? 목적
    - 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것
    - 인터페이스는 특정 개체가 수행해야하는 목록을 정의해놓은 명세서라고 보면 됩니다
    - 인터페이스를 통해 서로 다른 클래스간에 공통된 규격을 만들 수 있습니다. 그렇게 되면 유지관리가 쉬워집니다. 매번 A라는 부품을 만들기 위해 b,c,d가 필요하다는것을 알려주지 않아도 되니까요. A라는 인터페이스를 사용하는 사용자에게 b,c,d가 필요함을 강제함으로써 자연스럽게 규칙이 지켜질 수 있습니다
- 인터페이스에서 사용되는 상수, 메서드, 정적메서드, 디폴트 메서드 의 의미를 설명해주세요
    
    ```java
    public interface 인터페이스명 {
    	//상수
    	타입 상수명 = 값;
    	
    	
    	//추상 메소드
    	타입 메소드명(매개변수, ... );
    	
    	
    	 //디폴트 메소드
    	default 타입 메소드명(매개변수, ... ){//구현부}
    	
    	//정적 메소드
    	static 타입 메소드명(매개변수) {//구현부}
    }
    ```
    
    - 상수 : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조해라 (절대적)
    - 추상메소드 : 가이드만 줄테니 추상메소드를 오버라이팅해서 재구현해라. (강제적)
    - 디폴트메소드 : 인터페이스에서 기본적으로 제공해주지만, 맘에 안들면 각자 구현해서 써라. (선택적)> 이미 운영되고 있는 시스템에서 추가 요건으로 인해 불가피하게 반영을 해야할 때 디폴트메소드를 쓰면 효과적> 추가요건에 대한 대처를 할 수 있도록 유연성을 확보
    - 정적메소드 : 인터페이스에서 제공해주는 것으로 무조건 사용 (절대적)
- **추상클래스와 인터페이스의 차이**
    - 추상클래스 : 추상 메서드를 선언하여 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스입니다. 그래서 미완성 설계도라고도 표현합니다.
    - 인터페이스 : 추상클래스가 미완성 설계도라면 인터페이스는 기본 설계도라고 할 수 있습니다. 인터페이스도 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성하고 클래스와 다르게 다중상속(구현)이 가능
    - 추상클래스는 인스턴스 변수라는 상태를 가질 수 있습니다
    인터페이스는 접근제어자가 public하나인데 반해서 추상클래스는 public, protected, private을 가질 수 있습니다
    - 추상클래스나 클래스 상속은.. IS - A "~이다".
    - 인터페이스는 HAS - A "~을 할 수 있는".
- 오버로딩과 오버라이딩의 차이
    - 오버로딩:  매개변수의 타입이나 수로 구분된 중복이름함수를 정의할 수 있는 것
    - 오버라이딩: 부모로부터 상속받은 매서드를 자식객체가 재정의할 수 있는 것
- final vs static 차이
    - final : 상수 값을 만들고 싶을 때(수정이 불가능하다는 의미)
    - static : 객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 활용한다.
    - static final : 모든 영역에서 고정된 값으로 사용하는 상수
    - final method: **오버라이딩을 금지**
    - final class: 상속금지
- 깊은복사와 얕은복사의 차이
    - 깊은복사 - 메모리에 실제 공간을 하나 더 만들어서 그 공간을 참조하도록 하는것
    - 얕은복사 - 원본객체를 그저 참조만 하는 것
- Runtime Data Area에 대해 설명해주세요
    1. 모든 스레드가 공유하는 가비지 컬렉터의 대상
        
        1) 메서드 영역 : 클래스 파일의 바이트 코드가 로드되는 곳 
        
        - 힙영역처럼 자주 가비지 컬렉터가 회수하진 않지만 더이상 사용되지 않는 클래스르를 언로드 하긴 함
        
        2) 힙영역 :  new로 생성된 모든것이 생성됨
        
    2. 스레드별로 할당되는 영역
        
        3) 스택 영역: 지역변수, 임시값, 실행되는 메서드
        
        4) pc레지스터: 현재 스레드를 가리키는 포인터 저장
        
        5) native method stack: 자바외 언어로 작성된 코드를 위한 메모리 영역
        
        - native라는 키워드가 붙으면 자바로 구현한 코드가 아니라는 얘기다
    - final과 static은 메서드 영역에 존재한다. 왜냐면 인스턴스 별로 할당되는 변수가 아니기때문에..
    
    ```sql
    //동적인 final은 힙에 할당된다
    public class Car {
        final int maxSpeed;
    
        public Car(int max) {
            maxSpeed = max;
        }
    }
    //정적인 final은 메서드영역에 저장된다
    public class MathConstants {
        public static final double PI = 3.14159;
    }
    ```
    
- 자바의 동적로딩 vs정적로딩에 대해 설명해주세요
    - 동적로딩
        - 프로그램을 실행할 때, 필요할 때마다 동적으로 메모리를 생성하고, 필요없는 메모리는 자동으로 메모리에서 소멸시킨다.
        - 필요한 기능만 메모리에 불러와 사용하기 때문에, 큰 프로그램도 작은 메모리에서 실행이 가능하다.
        - 프로그램의 실행 속도가 느려질 수 있다.
        - ex) 자바
    - 정적로딩
        - 프로그램을 실행할 때, 모든 실행파일이 메모리에 로드된다.
        - 모든 기능이 메모리에 존재하므로, CPU가 필요로하는 기능을 빠르게 메모리에서 가져와 사용할 수 있다.
        - 메모리를 많이 차지한다.
        - ex) c언어
- Static 키워드의 장단점
    - Static 변수는 메모리에 한번 할당되어 프로그램이 종료될 때 유지되는 변수입니다
    class내에 static 변수는 class간에 공유되어야할 변수를 선언할때 사용하며
    class내의 static method는 class의 인스턴스 변수를 내부에서 사용하지 않을 경우에 주로 사용합니다
    - static을 사용하게되면 매번 인스턴스를 생성하지 않아도 사용할 수 있어서 속도측면에서 이득을 볼 수 있습니다.
    - 그에 반해 다음과 같은 단점도 가지고있습니다.프로그램 종료시 까지 메모리에 공간을 차지한다는 것입니다.
    - 가비지 컬렉터는 heap만 관리하지 static영역은 자주 관리하지 않습니다. 그래서 프로그램 퍼포먼스에 악영향을 줍니다.
    - static이라는 키워드자체가 객체지향적이지 못합니다. 데이터들이 캡슐화되어야한다는 객체지향의 원칙을 위반합니다.
- 리플렉션이란?
    - 구체적인 클래스 타입을 알지 못해도 클래스의 메서드, 타입, 변수들을 접근할 수 있게 해주는 Java API
    - 힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API
- 리플렉션 장단점
    - 장점
        - 런타임 시점에서 클래스의 인스턴스를 생성한다
        - 접근 제어자와 관계 없이 필드와 메소드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다.
    - 단점
        - 캡슐화 저해
- 리플렉션은 언제 사용하는가?
    - 가령 사용자가 덧셈을 입력하고 싶다고 하면 덧셈에 관한 class를 사용해야하고, 뺄셈이라고 명령어를 입력하면 뺄셈에 대한 class를 사용해야한다고 가정하자. 이를 일반적으로 구현하려면 if-else문을 사용해야한다. 하지만 리플렉션을 사용하면 다음과 같은 일이 가능하다
    
    ```java
    String className = getUserInput();
    Class<?> clazz = Class.forName(className);
    Object operation = clazz.newInstance();
    
    ```
    
    - 즉, 리플렉션을 사용하면 사용자 입력이나 설정파일과 같이 런타임에야만 알 수 있는 정보를 가지고 인스턴스를 생성할 수 있습니다
    - 가령, Spring의 Bean Factory를 보면, @Controller, @Service, @Repository 등의 어노테이션만 붙이면 Bean Factory에서 알아서 해당 어노테이션이 붙은 클래스를 생성하고 관리해 주는 것을 알 수 있다. 개발자는 Bean Factory에 해당 클래스를 알려준 적이 없는데, 이것이 가능한 이유는 바로 리플렉션 덕분이다. 런타임에 해당 어노테이션이 붙은 클래스를 탐색하고 발견한다면, 리플렉션을 통해 해당 클래스의 인스턴스를 생성하고 필요한 필드를 주입하여 Bean Factory에 저장하는 식으로 사용이 된다.
- **제네릭(Generics) 이란**
    - 데이터의 타입을 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미
    - 자바에서 타입 체크는 보통 컴파일에 수행됩니다
    근데 만약 제네릭이 없으면 List나 Map과 같은 컬렉션 작업할때 타입 체크가 제한됩니다
    제네릭이 없으면 모든 유형의 객체를 넣을 순 있으나 어떤 유형의 개체로 List를 선언했는지 컴파일러가 모르므로 개체를 올바르게 사용하고 있는지 알 수 없습니다
    
    ```java
    List list = new ArrayList();
    list.add("a string");
    list.add(42);//런타임 오류!
    
    ```
    
    - 제네릭을 사용하면 컬렉션이 갖는 타입을 컴파일러에게 알려서 컴파일러는 컴파일시간에
    컬렉션을 올바르게 사용하고 있는지 알 수 있습니다
    - 그러니까 제네릭 덕분에 런타임 오류를 컴파일에 알릴 수 있게 됩니다
- **SOLID(객체 지향 5대 원칙)에 대해 설명하세요.**
    - SRP(단일 책임 원칙) - 1개의 클래스는 1개의 책임만 가져야 한다.
    - OCP(개방-폐쇄 원칙) - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
    - **L**SP(Listov Substitution Priciple): 리스코프 치환 원칙: 자식은 언제나 부모타입으로 대체될 수 있어야한다
    - ISP(인터페이스 분리 원칙) - **객체가 자신에게 필요한 기능만을 가지도록 제한하는 원칙**입니다. 불필요한 상속과 구현을 최대한 방지함으로써 객체의 불필요한 책임을 제거합니다
    - DIP(의존관계 역전 원칙) - 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙
- list vs map의 차이점
    - Map은 검색할 수 있는 인터페이스이고, 데이터를 삽일할 때 Key와 Value의 형태로 삽입되어, Key를 이용해서 Value를 얻을 수 있다. 데이터 순서를 보장하지 않고, Key값은 중복 허용 X , Value값은 중복 허용
    - List는 순서가 있는 Collection이고, 데이터 중복이 허용된다.
    - List와 Map의 차이점은 List는 데이터 순서를 보장하지만, Map은 순서를 보장하지 않는다.
- 자바는 멀티스레드를 지원하는데. .  **멀티 스레드(Multi Thread) 사용할때의 장점은?**
    - 멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적다.
    - 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아진다.
    - 단점: 둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드 블록(임계영역)에 관한 문제가  추가적으로 생길 수 있습니다.
- 직렬화란?
    - Java에서 입출력할 때는 스트림이라는 데이터 통로를 통해 이동한다.
    - 객체를 바이트로 변환하여 네트워크 송수신이 가능하게 하는 과정이 직렬화입니다
    - 역 직렬화 : 네트워크로 전송받은 바이트 데이터 -> 객체


# JPA
- sql중심적인 개발의 문제점
    - 지루한 코드의 무한 반복
        - 기능 하나 추가해서 테이블을 하나 만들더라고, CRUD 쿼리를 다 짜야한다.
    - 객체 지향과 관계형 데이터베이스 간의 패러다임 불일치
        - 관계형 DB는 데이터를 잘 정규화해서 보관하는 것이 목표
        - 객체는 속성과 메서드로 잘 캡슐화해서 사용하는 것이 목표
        - 패러다임이 안맞는 객체를 관계형 DB에 넣으려하다보니 여러가지 문제가 생김
    - 객체 그래프 탐색에서의 **문제**
        - 마음껏 탐색할 수 없음. 내가 join을어디까지 했냐에 따라 탐색이 안될 수도 있음
    - “비교하기” 에서의 차이
        - 일반적인 SQL을 사용해서 두번 조회시, 반환되는 객체 두개는 ==비교했을 때 다르다
- 객체와 관계형 데이터베이스의 차이
    1. 상속 (객체에만 존재)
    2. 연관관계 (객체는 참조를 가지고 연관된 객체를 가져올 수 있음, DB는 PK와 FK로 조인해서 필요한 데이터 가져옴)
- 그래서 왜 jpa가 나온거야?
    - 객체를 자바 컬렉션에 저장하듯이 DB에 저장하고 싶은 목적때문에 나오게 됨
    
- jpa의 구동 방식
    - persistence에서 시작함 - META-INF/persisten.xml라는 설정정보를 조회한다
    - 그리고 EntityMagagerFactory를 만들고 필요할때마다 EntityManager를 생성한다
    

- EntityManagerFactory와 EntityManager
    - EntityManagerFactory는 DB당 하나씩만 생성된다. 애플리케이션 하나에서 공유한다.
    - EntityManager는 고객의 요청이올때마다 썼다가 버렸다가 한다
    - JPA는 스레드가 하나 생성될 때 마다(매 요청마다) EntityManagerFactory에서 EntityManager를 생성한다.
    - 스프링에서 EntityManager를 주입 받아서 쓰면, 같은 트랜잭션의 범위에 있는 EntityManager는 동일 영속성 컨텍스트에 접근한다.
    - 엔티티 매니저 내부에는 영속성 컨텍스트가 있으며, 이를 통해 엔티티 관리
    - 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유 가능??
    - EntitiyManager를 스레드간에 공유하면 안된다. 쓰면 버려야한다
    - 왜 스레드간에 em을 공유하면안되지?
        - 여러 스레드가 동일한 `EntityManager` 인스턴스를 공유하는 경우 데이터베이스에서 읽기 및 쓰기 작업을 동시에 수행할 수 있습니다.

- 엔티티의 생명주기
    - 비영속: 영컨에 있었던적이 없는 새로운 상태
    - 영속: 영컨에 의해 관리되는상태
    - 준영속: 영컨에 있었다가 분리된 상태
    - 삭제: 디비에서 삭제된상태
- 영속화된 entity의 특징
    - 같은 트랜잭션 안에서는 같은 id값이면 ==비교시 true가 뜬다
    
- 왜 굳이 트랜잭션 커밋시 db에 쿼리를날리는걸까? 바로바로 안하고?
    - 만약에 바로바로 db에 쿼리를 날리게 되면 최적화를 할 수가없다.
    - 불필요하거나 중복된 데이터베이스 쿼리 수를 줄일 수 있게된다
- 플러시가 발생하면 무슨일이 생길까?
    - 변경을 감지한다
    - 수정된 ENTITY에 대해선 UPDATE쿼리를 쓰기지연 SQL저장소에 넣어준다
    - 쓰기지연 SQL저장소에 있는 쿼리를DB로 전송한다
    - 1차캐시가 지워지진 않는다
    - 영속성 컨텍스트를 비우는것이 아니라 영속성 컨텍스트의 변경내역을 DB에 동기화하는것이다
- 영속성 컨텍스르를 flush 하는방법
    - commit시
    - em.flush()시
    - JPQL쿼리 실행시
- id생성전략 - identity에 대해 설명 (언제 insert쿼리가 날아가는가?)
    - 원래는 commit시점에 쿼리가 날라가는데 전략이 identity인 경우에만 em.persist를 한 동시에 쿼리가 날라가게 된다
    - 왜냐면 identity는 디비에 저장해야 pk값이 생기는건데 영속성 컨텍스트안에선 그럼 pk값이 뭔지 모르잖아 (db에 저장되기 전인)
- 연관관계의 주인을 정한다는 말의의미
    - 멤버의 team을 바꿨을 때 member의 team_id를 바꿀 것인가? team의 members가 바뀌었을때 member의 team_id를 바꿀것인가?
    - 보통은 객체의 두 관계중 하나를 연관관계 주인으로 지정(외래키가 있는 곳을)
    - 주인이 아닌 쪽은 읽기만 가능하다
    - 주인은 mappedBy 속성을 사용하지 않는다
    - 주인이 아니면 mappedBy 속성으로 주인을 지정한다
    
- 양방향 연관관계 setting시 양쪽에 값을 다 넣어줘야하는 이유
    - 원래는 fk하나로 연관관계가 결정되기때문에 한쪽에만 연관관계를 설정해도된다 그렇지만 디비에 저장하지 전까지 순수 객체 상태일 텐데 이 과정에서 연관관계에 맺어져있지만 아직 값이 들어가있지 않은 경우가 있을 수 있다(반대편에만 setting해서) 이를 고려해서 항상 양쪽에 값을 설정하자

- 일대일 관계에서는 unique컬럼을 필수로 등록해주어야한다
- ManyToMany를 지양해야하는 이유
    - 중간 테이블에는 매핑정보만 들어가고 추가 데이터를 넣는 것이 불가능하다. 에를들어 멤버랑 상품에 대한 중간테이블에는 멤버랑 상품을 매핑하면서 예를들어 상품구매시간 같은 추가 데이터를 못넣는다
    - 중간 테이블이 숨겨져 있기 때문에 쿼리가 예상하지 못하는 형태로 나간다.
- jpa에서 상속관계 매핑하는 법 3가지
    
    ### 조인전략

    - 앨범을 인서트 하면 아이템, 앨범에 두번 INSERT가 일어난다
    - 조회는 PK,FK로 수행한다
    - `ITEM-DTYPE`으로 이 아이템이 앨범인지 무비인지 북인지를 구분하는 컬럼을따로만든다
    
    ### 단일테이블 전략

    앨범, 책, 영화 각각이 가지는 컬럼들과 공통컬럼들을 그냥 모두 합쳐 하나의 테이블로 만든다
    
    그리고 이게 앨범인지 책인지 영화인지는 `DTYPE`을 통해 구분한다
    
- em.getReference이뭐야?
    - 디비조회를 미루는 가짜(프록시) 엔티티 객체를 조회하는거다
    - 디비 조회 쿼리 안날아감
    - 객체를 얻어낼땐 쿼리가 안날라가는데 .getId같이 호출을하면 그 시점에 select쿼리가 날라간다 그니까 해당 객체가 실제사용되는 시점에 쿼리를 날리는게 .getreference
- 프록시 객체특징
    - 실제 클래스를 상속 받아서 만들어짐
    - 실제 클래스와 겉 모양이 같다.
    - 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
    - 프록시 객체는 실제 객체의 참조(target)를 보관
        - 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출
    - 프록시 객체는 처음 사용할 때 한 번만 초기화
    - 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초
    기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
    - 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비
    교 실패, 대신 instance of 사용)
- n+1문제
    - 조회 시 1개의 쿼리를 생각하고 설계를 했으나 나오지 않아도 되는 조회의 쿼리가 N개가 더 발생하는 문제.
    - MEMBER 테이블 전체를 조회하면 MEMBER테이블조회쿼리한번, TEAM 테이블 조회쿼리 두번이 나간다. 해당 member에 맞는 team을 넣어줘야해요 그래서 member 객체에 들어가보면 team_id정보는 있는데 team객체는 없어요 그래서 select쿼리로 찾아야돼요 member 수만큼 찾게되니까 여러번의 쿼리가 나가요
- cascade(영속성전이), 개념, 언제사용가능한가?
    - 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속
    상태로 만들도 싶을 때
    - 이건 즉시로딩 지연로딩이랑 관계가 없는 개념이다
    - 소유자가 하나이고, 라이프사이클이 똑같을 때 쓸 수 있어
    
- jpa데이터타입을 분류해봐
    1. Entity타입
    • @Entity로 정의하는 객체
    • 데이터가 변해도 식별자로 지속해서 추적 가능
    • 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자(id)로 인식 가능
    2. 값 타입
    • int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
    • 식별자가 없고 값만 있으므로 변경시 추적 불가
    • 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

[https://www.inflearn.com/questions/158967/안녕하세요-entitymanager에-대해-궁금한-점이-있어-질문-남깁니다](https://www.inflearn.com/questions/158967/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-entitymanager%EC%97%90-%EB%8C%80%ED%95%B4-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%90%EC%9D%B4-%EC%9E%88%EC%96%B4-%EC%A7%88%EB%AC%B8-%EB%82%A8%EA%B9%81%EB%8B%88%EB%8B%A4)

- 스프링 컨테이너의 기본전략
    - **같은 트랜잭션 안에서는 여러 위치(여러 레포지토리)의 엔티티 매니저를 사용해도 항상 같은 영속성 컨텍스트에 접근**한다.

    - **트랜잭션이 다르면 동일한 엔티티 매니저를 사용해도 다른 영속성 컨텍스트를 사용**
    - 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. -> **멀티 스레드 상황에 안전함**
    - 트랜잭션 AOP란?
        
        *대상 메소드를 호출하기 전에 트랜잭션을 시작, 대상 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료*
        
        *트랜잭션 커밋 시 영속성 컨텍스트 플러시 => 변경 내용 데이터베이스에 반영*
        
        *예외 발생 시 트랜잭션을 롤백 -> 이때는 플러시 호출 X*
        
    - 뷰계층에서는 transactional 어노테이션 안사용하는이유
        - 애플리케이션 계층이 가지는 책임이 모호해짐
        - 유지보수성이 떨어진다.
        => 데이터가 어디서 어떻게 변했는지 프레젠테이션 계층까지 다 찾아야 함
    - 준영속 상태로 바꼈을떄의 단점
        - 뷰를 렌더링할 때 연관된 엔티티도 함께 사용해야 하는데 연관된 엔티티를 지연 로딩으로 설정해서 프록시 객체로 조회했다.
        - 초기화하지 않은 프록시 객체를 사용하면 실제 데이터를 볼러오기 위해 초기화를 시도한다.
        - 하지만 준영속 상태는 영속성 컨텍스트가 없으므로 지연 로딩을 할 수 없어 예외를 발생시킨다.
    - 위의 문제를 해결하는 방법(준영속으로바껴버려서 조회안되는문제)
        - FetchType.EAGER 사용
            - 사용안할것도 모두 불러올지도모름
            - n+1문제발생
        - JPQL 페치 조인으로 함꼐 가져오기
            - 무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가한다.
                - 프레젠테이션 계층이 알게 모르게 데이터 접근 계층을 침범하게 된다.
        - 강제로 초기화
            - 하지만 이렇게 서비스 계층은 비즈니스 로직을 담당해야지, 프레젠테이션 계층을 위한 일까지 하는 것은 좋지 않다.
            - 이렇게 서비스 계층이 프레젠테이션을 위한 일까지 하면 뷰에서 필요한 엔티티에 따라 서비스 계층의 로직이 바뀌어야한다.
            - 따라서 서비스 계층에서 프레젠테이션 계층을 위한 프록시 초기화 역할을 분리하고, 그 역할을 `FACADE 계층`이 담당해준다.
            - facade란?
                
                ```java
                class OrderFacade {
                    @Autowired OrderService orderService;
                    public Order = orderService.findOrder(id);
                    // 프레젠테이션 계층이 필요한 프록시 객체를 강제로 초기화
                    order.getMember().getName();
                    return order;
                }
                class OrderService{
                    public Order findOrder(id){
                        return ordeRepository.findOrder(id);
                    }
                }
                ```
                
                - 중간에 계층이 하나 더 생겨버린다. 즉 더 많은 코드를 작성해야 한다. -> 번거로움!
                - 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많을 것이다.
                - 화면별로 최적화된 엔티티를 딱딱 맞아떨어지게 초기화해서 조회하려면 여러 종류의 조회 메소드가 필요하다.
        - OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법
            - **뷰에서도 지연 로딩을 사용할 수 있도록 하는 것**
        
    - osiv의 과거방식 + 필요성 + 단점
        - 필요성:
            - 결국 모든 문제는 엔티티가 프레젠테이션 계층에서 준영속 상태이기 때문에 발생한다.
            - 따라서 **영속성 컨텍스트를 뷰까지 열어둠으로써 뷰에서도 지연 로딩을 사용할 수 있다.**
        - osiv의 과거방식
            - 클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 만들면서 트랜잭션을 시작하고, 요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 끝내는 방법
            이렇게하면 영속성 컨텍스트가 처음부터 끝까지 살아있으므로 조회한 엔티티도 영속 상태를 유지한다. -> **뷰에서 지연 로딩이 가능**하므로 엔티티를 미리 초기화할 필요 X, `FACADE 계층` 없이도 뷰에 독립적인 서비스 계층을 유지할 수있다.
            
        - osiv과거방식의 단점
            - 컨트롤러나 뷰 같은 프레젠테이션 계층이 엔티티를 변경할 수 있다.
        - osiv과거방식의 단점의 해결책
            - 위와 같은 문제를 해결하려면 프레젠테이션 계층에서 엔티티를 수정하지 못하도록 막으면 된다.
                - 엔티티를 읽기 전용 인터페이스로 제공
                - 엔티티 레핑
                - DTO만 반환
- 스프링이 제공하는 osiv는 기존 osiv의 어떤 단점을 보완했나?
    - 스프링이 제공하는 OSIV를 사용하면 프레젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다. -> 기존 OSIV의 단점 보완
    - 영속성 컨텍스트를 프레젠테이션 계층까지 유지
    - 프레젠테이션 계층에는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.
    - 프레젠테이션 계층에는 트랜잭션이 없지만 트랜잭션 없이 읽기를 사용해서 지연 로딩을 할 수 있다.
    - 컨트롤러에서 엔티티 수정 후 즉시 뷰를 호출하는 것이 아니라 트랜잭션이 동작하는 비즈니스 로직을 호출해서 발생하는 문제 → set자체는 가능함. biz로직 호출했을때 error가 터짐
    - 그러니까 biz로직 호출끝나고나서 set하면 error안남
    - 
    
- 스프링 osiv의 장점
    - OSIV를 사용하면 영속성 컨텍스트가 프레젠테이션 계층까지 살아 있어 미리 초기화할 필요가 없다.
    - **따라서 단순한 엔티티 조회는 컨트롤러에서 레포지토리를 직접 호출해도 아무런 문제가 없다!**
    
- spring.jpa.open-in-veiw = "true”을 설정하면?
    - osiv가켜진다. osiv가 켜진다는것은 다음을 의미한다
    1. Hibernate는 각각의 HTTP 요청에 대해 영속성 컨텍스트를 자동으로 열고, 응답이 완료될 때까지 영속성 컨텍스트를 유지합니다.
    2. View 계층에서 엔티티의 데이터를 사용할 때, Hibernate는 해당 데이터에 대한 지연로딩을 실행하고 필요한 데이터를 로딩합니다. 이는 OSIV 패턴이 지연로딩과 지연초기화 문제를 해결하는 데 도움을 줍니다.
    3. 트랜잭션 범위도 확장됩니다. 즉, Controller 계층에서 엔티티에 대한 변경이 이루어지면, 영속성 컨텍스트가 열려있는 상태에서 이루어지며, 이 변경은 트랜잭션 커밋 시점에 반영됩니다.
- 그냥 jpql사용하면 되잖아 왜 영속성 컨텍스트를 확장하는거야?
    - 너무 무분별하게 사용하면 뷰와 리포지토리사이의 논리적인 의존관계가 생긴다
    - 예를들어 다음과 같은 상황이있다고 가정하자
    1. 회원 A를 위해 order만 조회하는 메서드
    2. 회원 B를 위해 order과 delivery를 조회하는 메서드
    - → 이 경우 각각 두개 만드는것보단 하나로 합친다음에 1번이 좀더 느려지더라도 order만 빼서 사용하면 된다 너무 의존성이 심해지는것보단 이게 낫다.
    
- “트랜잭션 없이 읽기”에 대해 설명해보세요
    - 영컨은 트랜잭션 범위 안에서만 변경이 가능하다
    - 영컨은 트랜잭션 범위 밖에서도 조회를 할 수 있다 < “트랜잭션 없이 읽기”
- 만약에 비즈니스 계층 트랜잭션 osiv를 사용했는데, controller에서 entity를 변경하면 무슨일이 일어나나?
    - 영컨의 변경내용을 반영하려면 flush()가 호출돼야하는데 트랜잭션 범위내에 있지않아서 flush가 안됨
    - flush를 강제로 해주려고 해도 트랜잭션 범위가 아니여서 실패
    - 
- osiv가 뷰에서도 지연로딩이 가능하게 하려고 도입한거잖아요 (뷰에서 필요한값들을 지연로딩으로 가져오려고)
근데 지연로딩을 하면 결국 필요없는 쿼리가 추가로 나가게될텐데..애초에 필요한 데이터만 jpql사용해서 뽑아서 주면 문제가 해결되는거아닌가요? 왜osiv를 사용하는거죠?? 뷰와 리파지토리가 너무 연관되어서 그런가요..? 그게 그렇게 큰 단점인가요..?
    
    답변—
    
- osiv: 요청당 트랜잭션의 경우. biz()호출이후 setfield()를 호출하면 문제가 생긴다. 설명해보시오
    - 영속성컨텍스트의 범위내에 있기때문에 set을 하면 변경감지가 동작해서 값을 바꾸는 쿼리를 날린다. 그래서 문제가 생긴다
- 왜 osiv에서 프레젠테이션계층에서 biz() 호출 전에 setfield하면 error가 나는건가요?
왜 엔티티 수정 직후 뷰를 호출하면 이런 문제가 안생기나요?
    - 원래 영속성 컨텍스트내부에 있어서 변경감지가 일어나긴했는데 트랜잭션 범위밖이여서 update쿼리가 나가지않는거였는데, biz()에 들어가면서 트랱잭션 범위내에 들어가게된다. 그러면서 update쿼리를 생성하게된다. biz를 안거치기만 하면 해결된다. 마지막에 setfield를 사용하면 이 문제는 해결된다
- 동일성 비교, 동등성 비교
    
    동일성 비교 : 인스턴스의 참조 값을 비교, == 사용
    
    동등성 비교 : 인스턴스의 값을 비교, equals()사용
    
- 언제 임베디드 타입 을 사용해야할까?
    - 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것
    은 값 타입이 아닌 엔티티
    - 임베디드 타입은 변경감지에 영향을 받지않는다
    
- 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
    
    일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
    
    근데 일대다 같은 데이터 뻥튀기기 되는것들은 페이징을 할 수 없어
    
- jpql을 실행시켜서 결과를 받아왔는데 그 결과가 영컨에 있으면 자기가들고왔던것을 버린다. 왜그러는것일까?
    - 영컨은 영속상태인 엔티티의 동일성을 보장해주어야하기때문
- jpql 주의사항
    - jpql은 영컨 안 들르고 바로 디비에쿼리날리기때문에 jpql 실행전엔 항상 flush가 일어나야한다.
    - 기본설정은 auto로 jpql실행 직전에 플러쉬가 된다. 플러시모드는 우리가 따로 설정할 수 있다.
- 플러쉬모드:commit 이 필요한 상황
    1. 성능 향상:  이럴 때 COMMIT 모드로 설정하면 트랜잭션 커밋 시에만 플러시가 발생하므로 성능을 향상시킬 수 있습니다.
    2. 데이터 일관성 유지: 커밋이전까지는 다른 사용자가 해당 데이터를 조회하는 상황에서 커밋 이전의 내용을 보게 하고싶을때 commit모드를 사용할 수 있다
    
- 트랜잭션 aop에 대한 설명
    - 서비스 계층에 @Transactional 어노테이션이 붙어있으면 트랜잭션이 시작된다 근데 이 메서드 실행직전에 트랜잭션 aop가 먼저 동작한다
    - 스프링 컨테이너는 트랜잭션 범위의 영컨 적략을 기본으로 사용한다
    - 트랜잭션범위 == 영컨 범위 라는 얘기다
    - 트랜잭션이 같으면 같은 영속성컨텍스트를 사용한다
    - 엔티티매니저는 다른데 트랜잭션이 같아서 같은 영속성컨텍스트를 사용할 수 있다
    - 스프링컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 즉, 다른 스레드가 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 달라서 멀티스레드 상황에 안전하다
- 뷰에서 지연로딩하는 경우 프록시객체를 참조해서 error터질때의 근본적인 문제
    - 미리 로딩해두는방식은 별로다. 왜냐면 애플리케이션 로직과 뷰가 논리적으로 서로 의존하기때문이다.
- osiv의 변화과정
    - 요청 당 트랜잭션 → 비즈니스 계층 트랜잭션
    - 요청당트랜잭션: 요청 들어오자마자 영컨을 만들면서 트랜잭션도 시작
        - 컨트롤러/뷰 같은 프레젠테이션 계층이 엔티티변경가능해짐
    - 비즈니스계층트랜잭션: 요청들어오자마자 영컨생성 + 트랜잭션은 비즈니스 계층부터
- 스프링osiv의 특징
    - 요청이 들어올때마다 영컨 생성해서 요청이 끝날때까지 같은 영컨을 유지한다.
    - 같은 영컨을 여러 트랙잭션이 공유할 수 있다(트랜잭션 롤백시 주의 (15.1.4)
    
- 엔티티 그래프 관련 공부
    
    
- **JPA 표준 예외 정리**
    
    1) 트랜잭션 롤백을 표시하는 예외
    
    - 심각한 예외로 트랜잭션을 강제로 커밋해도 RollbackException 에러 발생
    
    2) 트랜잭션 롤백을 표시하지 않는 예외
    
    - 심각한 예외가 아니므로 개발자가 트랜잭션을 커밋할지 롤백할지 결정할 수 있음
