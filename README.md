# 목차
- [네트워크](#네트워크)
- [운영체제](#운영체제)
- [데이터베이스](#데이터베이스)
- [자바](#자바)
- [JPA](#JPA)
- [스프링](#스프링)
- [자료구조](#자료구조)

# 네트워크
- **쿠키 vs 세션에 대해 설명해주세요**
    - 둘다 HTTP의 stateless한 특성을 보완하기 위해서 나온 기술입니다. 로그인을 유지하는것과 같은 상태유지가 필요할때 사용합니다
    - 쿠키는 저장해야할 데이터가 클라이언트측에 저장되고, 세션은 데이터를 서버측에 저장하고 관리한다는 차이가 있습니다
- **쿠키와 세션의 필요성**
    - HTTP 프로토콜의 경우 “Connectionless, Stateless”한 특성이 있어 요청간에 의존관계가 없습니다.
    - 또한 매 통신마다 새로 연결해야 하기 때문에 현재의 클라이언트가 이전 접속자와 같은지를 알 수 있는 방법이 없습니다. 이 점을 보완하는 데 쿠키와 세션이 사용됩니다.
- 쿠키와 세션의 동작방식
    - **쿠키 동작방식**
        1. 클라이언트가 서버에게 요청을 보냅니다
        2. 서버에서 쿠키를 생성하고 HTTP 헤더에 쿠키를 포함 시켜 응답합니다.
        3. 이제 클라이언트측은 HTTP 헤더에 쿠키를 함께 보냅니다.
    - **세션 동작방식**
        1. 클라이언트가 인증에 성공하면 세션 ID를 발급 받습니다.
        2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있습니다.
        3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청합니다.
        4. 서버는 세션 ID를 전달받아서 세션 Id를 통해 세션저장소(디비)에 있는 클라이언트 정보를 가져와서 사용합니다.
        5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답합니다.
- **쿠키와 세션은 언제 사용하나요?**
    - 쿠키
        - 클라이언트 로컬에 저장되므로 보안에 취약해 로그인같은 인증에는 잘 쓰이지 않습니다.
        - 단순한 **아이디의 저장**이나, **쇼핑몰의 장바구니 담아두기** 같은 기능에 사용합니다.
    - 세션: 보안상 중요한 작업인 **로그인 기능**에 사용됩니다.
- **세션기반 인증방식과 토큰기반 인증방식의 차이 (Token 기반 vs Session 기반)**
    - 두방식의 가장 큰 차이점은, 세션은 데이터베이스 서버에 저장된단는 점,
    - 토큰은 클라이언트 측에서 저장한다는 점입니다.
    - **세션기반인증방식**은, 클라이언트에게 세션 ID를 발급해, 세션 정보를 서버에 저장하여 사용자를 검증하는 방식입니다.
    - **토큰기반방식**은, 따로 정보를 DB에 저장하지 않고 인증된 사용자에게 토큰을 발급하여, 서버에 요청시 토큰을 함께보내고, 이 토큰이 유효하지 확인하여 검증하는 방식입니다.
- **HTTP 프로토콜에 대해 설명해주세요.**
    - HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 규약입니다.
    - HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트와 데이터를 주고받은 뒤 연결을 끊는 Connectionless의 특징을 가지고 있습니다.
    - 장점
        - 상태를 유지하지 않고 해당 요청에 대한 응답만을 내려주면 돼서 서버 디자인이 간단합니다.
    - 단점
        - 이전 통신의 정보를 모르기 때문에 매번 인증정보를 같이 보내줘야 한다.
        - 이를 해결하기 위해 쿠키(cookie)나 세션(session)을 사용해서 데이터를 처리한다.
- stateless, connectionless에 대해 설명해주세요`
    - `connectionless`: 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지 하지 않는 것이다.
    - 이를 통해 서버의 자원을 효율적으로 관리하고, 수 많은 클라이언트의 요청에도 대응할 수 있게 한다
        - 현재는 이 문제를 **HTTP 지속 연결**로 문제를 해결했다.
            - 지속 연결은 요청에 따라 연결이 된 이후 일정 시간 연결을 유지하는것을 말함
    - `stateless`: 서버가 클라이언트의 이전 상태를 보존하지 않는다는 의미이다 (단계별 처리 시 이전 단계의 요청또한 같이 줘야 이해를 할 수 있음)
- http와 https의 차이
    - **HTTP 메시지는 일반 텍스트이므로, 권한이 없는 당사자가 인터넷을 통해 쉽게 액세스하고 읽을 수 있습니다.**
    - **반면, HTTPS는 모든 데이터를 암호화된 형태로 전송해서 쉽게 엑세스할 수 없습니다**
    
- 세션쿠키/지속쿠키 차이점
    - **세션 쿠키**: 만료 날짜/시간을 **지정하지 않으면** 세션 쿠키라고 하는데요 브라우저가 종료되면 쿠키가 사라집니다
    - **지속 쿠키**: 만료 날짜/시간을 **지정하면** 지속 쿠키라고 합니다. 브라우저가 종료되어도 만료날짜에 사라집니다
    
- www.domain.com에 들어가면 어떤 일이 일어나나요?
    1. 사용자가 브라우저에 URL을 입력
    2. DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음
    3. IP 주소로 웹 서버에 TCP 3 handshake로 연결 수립
    4. 클라이언트는 웹 서버로 HTTP 요청 메시지를 보냄
    5. 웹 서버는 HTTP 응답 메시지를 보냄
    6. 도착한 HTTP 응답 메세지가 처리되어 웹 브라우저에 의해 출력
    

- **TCP와 UDP의 차이를 설명해주세요.**
    - **TCP**는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다.
    - **UDP**는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.
    - TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.
    - 3-way handshaking 과정을 통해 연결을 설정하고,
    - 4-way handshaking 과정을 통해 연결을 해제한다.
- OSI-7계층에 대해서 각각 설명해보세요
    - 7 계층(응용 계층) : 우리가 사용하는 응용 서비스나 프로세스가 바로 응용계층에서 동작.
        - http 프로토콜이 응용계층이다
        - 사용자와 가장 가까운 계층이다
    - 6 계층(표현 계층) : 전송하는 **데이터의 표현방식(데이터변환,압축,암호화)**을 결정한다
    - 5 계층(세션 계층) 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
        - **TCP/IP 세션을 만들고 없애는 역할**
    - 4 계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 (단위 :Segment) (ex. TCP, UDP)
    - 3 계층(네트워크 계층) : 패킷을 목적지인 특정 IP까지 가장 빠른 길로 전송하기 위한 계층 (단위 :Packet) (ex. Router)
        - **경로(Route)와 주소(IP)를 정하고 패킷을 전달**해주는 것이 이 계층의 역할이다.
        - 즉, **목적지까지 가장 안전하고 빠르게 데이터를 보내는 기능**을 말한다. 따라서 **최적의 경로를 설정**해야 한다.
        - 이런 라우팅 기능을 맡고 있는 계층이 네트워크 계층이다.
    - 2 계층(데이터링크 계층) :물리계층에서 송수신되는 데이터들의 에러 검출, 흐름 제어를 담당하는 계층 (단위 :frame) (ex. 이더넷)
    - 1 계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층 (단위 :bit) (장비: 케이블,리피터,허브)
        - 단지 데이터를 전달하고 받기만할뿐 오류검출안함
- HTTP METHOD에 대해 설명해주세요
    
    
    | 종류 | 기능 |
    | --- | --- |
    | GET | 데이터 조회 |
    | POST | 요청 데이터 처리(보통 데이터 등록 사용) |
    | PUT | 데이터 변경 (해당 데이터가 없으면 생성) |
    | PATCH | 일부 데이터만 변경 |
    | DELETE | 데이터 삭제 |
- GET과 POST의 차이
    - **GET**은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다. URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다.
    - **POST**는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다. 완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다.
- http only란?
    - **브라우저에서 쿠키에 접근하지 못하게 방지해주는 속성**
- jwt란?
    - json web token
    - JWT는 헤더(Header).내용(Payload).서명(Signature)로 구성되며 각 파트를 점(.)으로 구분합니다.
    - **헤더(Header) :** 토큰 타입과 + 암호화 알고리즘
    - **내용(Payload) :**사용자가 담고자 하는 정보를 담는다. JSON(Key/Value)형태의 한 쌍
    - **서명(Signature) :**토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.
- xss란?
    - 사이트에 접속한 사용자는 악성 스크립트를 실행하게 되며, 보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등 민감한 정보를 탈취한다.
    - 자바스크립트로 쿠키정보를 얻어낼 수 있는데 httponly설정을 주면 이를 막아준다
- jwt를 어떻게 사용해야할까?
    - http only를 사용하자: xss를 예방할 수 있다
    - https를사용하자: 해커들은 쿠키를 탈취하였다고 하여도 암호화가 되어 있어 정보를 알아 낼 수 없습니다
    - refresh token사용을 하는것도 괜찮긴한데… 무제한으로 사용하면 안된다고 한다.. 이건 이유를 모르겠다 무제한으로 사용해야하는거아닌가? refreshtoken의 경우에만 블랙리스트를 도입하는거지.. 그러면 괜찮지않나..?
    
- 대칭키와 비대칭키
    - 대칭키와 비대칭키는**양방향 암호화 방식**
    - **대칭키 :** 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘입니다.
        - 이는 중간에 누군가 암호 키를 가로채면 암호화된 정보가 유출될 수 있다는 단점이 있는데, 이런 문제를 보완한 새로운 방식이 비대칭키(공개키)입니다.
    - **비대칭키**는암호화와 복호화할 때 키를 서로 다른 키로 사용하는 암호화 알고리즘입니다.
        - 타인에게 절대 노출되어서는 안되는 개인키(private key)와 공개적으로 개방되어 있는 공개키(public key)를 쌍으로 이룬 형태입니다.
        
- RSA란?
    - JWT가 쓰는 암호화방식
    - 얘는 public key(공개키), private key(개인키) 두개를 가진다
    - A->B가 message를 보내고싶다
    - 각자 개인키, 공개키를 들고있고, A의 개인키는 A만이 들고있다
        1. A는 일단 B가 만든 B의 공개키로암호화해서 message를 보낸다
        해커가 이 message를 탈취하더라도 열 수 없다. 
            
            B의 공개키로 잠궈진 message는 B의 개인키로만열수있기때문이다
            
            이 방법으로 다음 문제를 해결할 수 있다 `열쇠전달문제`
            
        2. 반대로 이번엔 노출되도 상관없는 정보를 보낸다고가정하자. 단, 이때 누가보냈는지는 알아야한다고 가정하자
            
            그러면 A->B에게 message를 보내는데 자신의 개인키로 암호화를한다. 그러면 B는 A의 공개키로 암호를 풀 수 있다. 그렇기에 B는 A가 보냈음을 확신할 수 있다. 중간에 해커가 채가더라도 중요하지않은 정보이기때문에 채가도 상관없다
            
    - 1번에서 A->B로보내는 message를 해커가 볼 순 없지만 가로채가서 다른것으로 바꿀 순 있다 그래서 이 데이터를 A의 개인키로 한번 더 잠군다
    - B는 문서를 받으면 A의 공개키로 열고, 열리면 인증이 해결되는것이다(A가 보냈음이 확신)
    열리면 자신의(B) 개인키로 열어본다. -> 암호화도 가능한다

- ****Connection Timeout과 Read Timeout의 차이에 대해 설명해주세요****
    - 서버 자체에 클라이언트가 어떤 사유로 접근을 실패했을 시 Connection Timeout
    - 클라이언트쪽은 문제가 없는데 서버측에서 응답에 쓰는 시간이 너무 길어져서 클라이언트가 연결을 해제하는 것이 Read Timeout
- PRIVATE IP VS PUBLIC IP
    - 퍼블릭 IP
        - 인터넷에서 장치를 식별하는데 사용할 수 있는 고유 IP입니다
    - 사설IP
        - 사설IP는 전역적으로 고유 하지 않고 로컬 네트워크 내에서만 엑세스할 수 있습니다
        - 하나의 공유기에 여러 기계가 연결되어있을때 각각의 기계는 사설IP를 사용합니다.
    - 그러니까 만약 라우터 한대에 노트북A와 노트북B가 있다면 노트북A와 B는 공통적인 공용IP(라우터것) 을 사용하고 사설네트워크내에서의 통신이 필요할때면 사설IP를 사용합니다
- **[ TCP와 HTTP 차이 ]**
    - HTTP는 비연결형 프로토콜인 반면에 TCP는 연결형 프로토콜
    - HTTP는 단방향 통신만 가능한 반면에 TCP는 양방향 통신이 가능함
    - HTTP는 응용 계층(7) 프로토콜인 반면에 TCP는 전송 계층(4) 프로토콜
    
# 데이터베이스
- DBMS를 정의하십시오.
    - 데이터베이스: 정보의 모음
    - 데이터베이스관리시스템: 데이터베이스와 사용자를 연결시켜주는 sw.
        - 말그대로 DB를 관리하기 쉽게 도와주는 SW
- RDBMS를 정의하십시오.
    - 관계형 데이터베이스를 관리하는 프로그램
    - 관계형 데이터베이스:  **구조화된 테이블로 데이터를 구성하는 디비 종류중 하나**
- 데이터베이스에서 다양한 유형의 관계는 무엇입니까??
    
    **답변 :** 데이터베이스에는 3 가지 유형의 관계가 있습니다.
    
    - **일대일 :** **`1:1 관계`**란 어느 엔티티 쪽에서 **상대 엔티티와 반드시 단 하나의 관계를 가지는 것**을 말한다. 예를 들어, 우리나라에서 결혼 제도는 일부일처제로, 한 남자는 한 여자와, 한 여자는 한 남자와 밖에 결혼을 할 수 없다. 남편 또는 부인을 2명 이상 둘 수 없는데, 이러한 관계가 `1:1 관계`다.
    - **일대다 :** 한쪽엔티티가 다른쪽 엔티티 여러개와 관계를 맺는 상황. 예를들면 하나의 팀에 여러 멤버가 속할 수 있는상황
    - **다대다 :** 관계를 가진 **양쪽 엔티티 모두에서 `1:N 관계`를 가지는 것**을 말한다.
    즉, **서로가 서로를 `1:N 관계`로 보고 있는 것**이다. 가령 학생은 여러 수업을 들을 수 있고 하나의 수업에 여러 학생이 있을 수 있는 상황을 말합니다
- 데이터베이스 언어(SQL)에 대해 설명하세요.
    
    **답변 :** SQL 문은 기본적으로 DDL, DML 및 DCL의 세 가지 범주로 나뉩니다.
    
    **DDL (데이터 정의 언어)** : 테이블 객체의 생성, 변경, 삭제 명령어를 뜻합니다. 예를 들어, create, alter, drop, rename 등이 있습니다. schema, domain, table, view, index를 정의, 변경, 삭제할 때 사용하는 언어입니다. → 데이터 구조를 정의하는 명령어
    
    **DML (데이터 조작 언어) 레코드 제어 명령어 입니다. 예를 들어, select, insert, update, delete 등이 있습니다.**
    
    **DCL (데이터 제어 언어)** ; 권한을 제어하는 언어로 사용자 권한을 제한 하거나 할때 사용함
    
- 정규화와 비정규화를 설명하십시오.
    - **정규화: 데이터베이스에서 중복을 제거해서 구조화하는 과정**
    - **비정규화: SQL성능을 높이기 위해서 일부러 정규화를 깨는 과정**
- 정규화의 장점/단점
    - 장점: 중복제거로 용량 확보
    - 단점: JOIN연산이 많아질 수 있씁니다
- 데이터베이스 뷰란?
    - **원하는 데이터만 뽑아서 보여주기 위해 하나 이상의 테이블에서 유도된 가상 테이블**입니다.
    1. 쿼리의 복잡성을 단순화할 수 있다
    2. 뷰는 sql문을 저장하는거다 sql문의 결과가아니라. 만약 자주 재사용되는 sql문이 있다면 뷰를 사용해서 sql문을 재사용할 수 있다. 메서드같이 말이다. 수정포인트가 한곳으로 줄어드니 효율적이다
    3. 보안기능을 적용할때도 뷰가 효과적이다 . 예를들어 학생과 교사 의 권한에 따라 학생id를 교사한텐 안보여줘야한다면.. 교사뷰와 학생뷰를 따로 만들어서 sql쿼리 단계라는 가장 깊은 단계에서부터 데이터가 감춰진 채로 반환이된다. 이는 좋은 보안성을 제공해준다
        - service단에서 학생id를 —-로 제공할수도있으나 항상 우리는 오류의 가능성을 포함해야한다. 애초부터 학생id를 제공하지 않는 뷰를 사용하면 보안상 더 좋다

- ER 모델은 무엇입니까?
    - Entity-Relationship Model(다이어그램)
    - 데이터베이스 설계에 사용되는 테이블을 시각화한 도구입니다
- 데이터베이스 트랜잭션이란 무엇입니까?
    - 데이터베이스의 작업단위입니다
    - 트랜잭션 도중에 실패하면 롤백되고 모두 성공해야만 커밋이 됩니다
        - 롤백은 트랜잭션 시행 이전으로 돌아가는것을 말하며
        - 커밋은 변경사항이 실제 디비에 반영되는것을 말합니다
- 인덱스란?/언제사용해야하나요?
    - 책의 목차와 같은 sql 속도를 높여줄 수 있는 자료구조 입니다
    - 인덱스는 인덱스 컬럼을 도입해서 빠르게 데이터를 추출할 수 있을때 사용합니다 보통 많은 데이터에서 소량만 추출할 경우 사용하죠
        - 많은 데이터에서 많은 데이터를 추출하는 경우엔 불리해요
        - 왜냐면 인덱스를 사용할경우 index range scan을 쓰게 되는데 이게 디스크 블록읽을때 조금씩 가져옴 그래서 많은 데이터를 추출해야할때 비요율이 발생한다
- 기본 키(Primary key)와 복합 키(Compound key)를 설명하십시오.
    - **기본 키** : 레코드 고유 식별 컬럼
    - 기본키와 복합키는 둘다 레코드를 유일하게 식별할수있는 컬럼인데그게 1개면 기본키고 2개이상이면 복합키
- Unique 키가뭐임?
    - Unique키: 유일성을 가지는 컬럼
    - 여러개 생성가능/NULL가능
- 디비 트리거가 뭐임  + + 왜 사용함?
    - 테이블에서 삽입 전, 삽입 후, 업데이트시, 행 삭제시와 같은 **이벤트가 발생할 때 자동으로 실행되는 명령 세트**를 데이터베이스 트리거라고합니다.
    - 업무 처리 자동화 / 무결성 강화에도 도움
- 'DELETE', 'TRUNCATE' 'DROP'의 차이는?
    - DELETE는 한 번에 한 행씩 테이블에서 특정 행을 제거하는 데 사용됩니다.
        - 큰 테이블의 경우 레코드를 개별적으로 제거하고 각 삭제를 기록하기 때문에 시간이 걸릴 수 있지만 WHERE 절을 사용하여 제거할 레코드를 선택할 수 있습니다
        - 테이블 데이터 삭제 (로그 o, 삭제조건설정가능, 느림).
    - **TRUNCATE:** 테이블에서 모든 레코드를 신속하게 제거하지만 유지할 레코드를 지정할 수는 없습니다. 또한 개별 행 삭제를 기록하지 않으므로 더 빠릅니다.
        - 테이블에서 모든 행이 제거됩니다. 그러나 테이블의 구조, 열, 제약 조건, 인덱스 등은 그대로 유지됩니다. 단순히 데이터 테이블을 비우는 것입니다.
        - 테이블 데이터 삭제 (로그 X, 삭제조건설정불가, 빠름)
    - DROP: DROP은 상자와 함께 피자를 통째로 버리는 것과 같습니다. 피자와 용기가 모두 사라졌습니다. 마찬가지로 데이터베이스에서 DROP은 데이터와 구조를 포함하여 전체 테이블을 제거합니다. 테이블이 존재하지 않는 것과 같습니다.
        - 테이블 자체 삭제
- 이상현상이란?/ 이상의 종류는?
    - 데이터베이스에서 정규화를 수행하지 않으면, 데이터의 중복이 발생하고 전체적인 무결성(정확성)이 저하됩니다. 이러한 원인은 데이터 **이상 현상(Anomaly)**에 의해 발생하며, 이상 현상으로 인해  현실세계의 실제 값과 데이터베이스에 저장된 값이 일치하지 않는 문제가 발생합니다..
    - → 즉, 이상현상: 디비 정규화를 제대로 수행하지 않으면 겪을 수 있는 여러 문제 상황
    - 다음은 이상 현상을 설명할 대학교 테이블입니다.
    
    | 학번 | 학생명 | 학과 코드 | 학과명 | 학과장 코드 | 학과장명 |
    | --- | --- | --- | --- | --- | --- |
    | 1 | 도우너 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | 2 | 고길동 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | 3 | 또치 | 102 | 물리학과 | 2000 | 아인슈타인 |
    | 4 | 마이콜 | 102 | 물리학과 | 2000 | 아인슈타인 |
    | 5 | 둘리 | 103 | 컴퓨터공학과 | 3000 | 빌 게이츠 |
    
    ---
    
    ### **삽입 이상(Insertion anomaly)**
    
    - **삽입 이상**은 특정 데이터가 존재하지 않아 중요한 데이터를 데이터베이스에 삽입할 수 없을 때 발생합니다.
    - 대학교 테이블에서 기본키는 '학번'입니다. 새로운 행을 삽입하기 위해서는 기본키인 '학번'이 필수입니다.
    - 현재 3개의 학과(경영학과, 물리학과, 컴퓨터공학과)가 존재하고 신설학과인 '수학과'가 새로 생겼으며, 대학교 테이블에 데이터를 추가해야 합니다.
    
    !https://blog.kakaocdn.net/dn/cpMjgF/btrmoqwcdRP/3KxplydxU6AQDVaUzyQaSk/img.png
    
    - 하지만, 신설학과인 '수학과'에는 학생이 존재하지 않기 때문에 대학교 테이블에 데이터를 추가할 수 없습니다.
    - 이러한 현상을 **삽입 이상**이라고 합니다.
    - 물론, 정규화에 의해 대학교 테이블을 학생 테이블, 학과 테이블로 분리한다면 데이터를 추가할 수 있지만, 설명하고 있는 예시는 정규화가 되지 않은 상태라고 가정합니다.
    - → 당연히 삽입이 돼야하는데 안되는 상황(정규화가 제대로되지않아서 문제발생)
    
    ---
    
    ### **삭제 이상(Deletion anomaly)**
    
    - **삭제 이상**은 특정 정보를 삭제하면, 원치 않는 정보도 삭제되는 현상입니다.
    - 컴퓨터공학과의 둘리 학생이 자퇴해서 데이터를 삭제해야 하는 경우 컴퓨터공학과의 학과 코드 및 학과장 정보도 삭제됩니다.
    
    !https://blog.kakaocdn.net/dn/ybtso/btrmoqwcn0M/J1CenPLzallpiHHhjD3Lok/img.png
    
    - 둘리 학생의 데이터를 삭제하면, 컴퓨터공학과의 학과 코드와 학과장 정보를 특정 테이블에 저장하지 않았기에 데이터가 소멸되는 문제가 발생합니다.
    - 이러한 현상을 **삭제 이상**이라고 합니다.
    - 삽입 현상에서 설명했듯이 정규화에 의해 테이블을 분리하면 삭제 이상을 해결할 수 있습니다.
    
    ---
    
    ### **업데이트 이상(Update anomaly)**
    
    - 테이블의 특정 데이터를 업데이트했는데, 정상적으로 변경되지 않은 경우 그리고 너무 많은 행을 업데이트하는 것을 **업데이트 이상**이라고 합니다.
    - 경영학과의 학생이 100명이라고 가정하고 경영학과의 학과장이 이름을 개명해서 학과장명을 변경해야 하는 경우입니다.
    
    | 학번 | 학생명 | 학과 코드 | 학과명 | 학과장 코드 | 학과장명 |
    | --- | --- | --- | --- | --- | --- |
    | 1 | 도우너 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | 2 | 고길동 | 101 | 경영학과 | 1000 | 워런 버핏 |
    | ... | ... | ... | ... | ... | ... |
    | 100 | 둘리 | 101 | 경영학과 | 1000 | 워런 버핏 |
    - 경영학과의 학생이 100명이므로 100개의 데이터를 변경해야 합니다.
    여기서 변경되지 않은 행이 한 개라도 존재하면, 데이터가 상이한 문제가 발생합니다.
    - 그리고 학생이 1000명이라면, 1000개의 데이터를 변경해야 하는 비효율적인 문제가 발생합니다. 이러한 현상을 **업데이트 이상**이라고 합니다.
- 데이터베이스 무결성이란?
    - 데이터의 정확성과 일관성을 유지하고 보증하는 것을 의미한다
    - **개체 무결성**
        - 서로 다른 두 튜플은 같을 수 없음.
        - 기본키는 NULL값이나 중복값을 가질 수 없다.
    - **참조 무결성**
        - 관련된 테이블의 레코드 간의 관계를 유효하게 하는 규칙
        - 외래키는 항상 NULL이거나 참조 테이블의 기본키 값이어야함
- 조인에 대해 설명하고 조인의 종류에 대해 말하세요.
    - 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법입니다.
    - **Inner Join** 은 2개 이상의 테이블에서 교집합만을 추출
    - **Left Join** 은 2개 이상의 테이블에서 from에 해당하는 부분을 추출
    - **Right Join** 은 2개 이상의 테이블에서 join하는 테이블에 해당하는 부분을 추출
    - **Outer Join** 은 아웃터 조인 또는 풀 조인이라고 말함, 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출 (합집합)

- 교착상태란? / 방지하려면?
    - 2개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 **교착상태** 라고 합니다.
    - 두개의 트랜잭션 작업이 서로 완료 될 때 까지 기다리게 되며 결과적으로 아무것도 완료가 되지 않는 상태
    
    <<방지법>>
    
    - 트랜잭션을 자주 커밋한다.
        1. 트랜잭션 A는 테이블 1의 행을 업데이트한 다음 테이블 2의 행을 업데이트하려고 시도합니다.
        2. 트랜잭션 B는 테이블 2에서 동일한 행을 업데이트한 다음 트랜잭션 A가 업데이트한 테이블 1에서 동일한 행을 업데이트하려고 시도합니다.
        
        이제 트랜잭션 A는 트랜잭션 B가 테이블 2의 잠금을 해제하기를 기다리고 있고 트랜잭션 B는 트랜잭션 A가 테이블 1의 잠금을 해제하기를 기다리고 있기 때문에 교착 상태에 빠졌습니다. 둘 다 진행할 수 없으며 교착 상태가 발생합니다.
        
        그러나 트랜잭션 A가 테이블 1을 업데이트한 직후, 테이블 2를 업데이트하려고 시도하기 전에 트랜잭션 A를 커밋한다고 가정해 보겠습니다. 이제 테이블 1에 대한 변경 사항이 저장되고 테이블 1에 대한 잠금이 해제됩니다. 이제 트랜잭션 B가 테이블 1을 업데이트하려고 하면 더 이상 트랜잭션 A에 의해 잠기지 않고 대기 없이 진행할 수 있습니다.
        
        - 자주 커밋하면 LOCK이 빨리 해제되니까 해결되는듯
    - 정해진 순서로 테이블에 접근한다
        - 프로세스 A는 리소스 1을 잠그고 리소스 2를 필요로 합니다.
        - 프로세스 B는 리소스 2를 잠그고 리소스 1이 필요합니다.
        - 항상 리소스 2보다 먼저 리소스 1을 잠그는 것과 같이 항상 특정 순서로 리소스를 잠그면 이러한 상황을 피할 수 있습니다. 그 이유는 실행할 두 번째 프로세스가 자원 1을 잠그기 전에는 자원 2를 잠글 수 없기 때문입니다(첫 번째 프로세스가 이미 잠근 상태이므로).
- NoSQL이 기존 RDBMS와 다른 점은?
    - **NoSQL** 은 스키마가 없습니다. 즉 데이터 관계와 정해진 규격(table-column의 정의)이 없습니다.
    - 관계 정의가 없으니 Join이 불가능하고 트랜잭션을 지원하지 않습니다.
    - 분산처리(수평적 확장)의 기능을 쉽게 제공한다는 장점이 있습니다.
- ****SELECT 쿼리의 수행 순서를 알려주세요.****
    
    *FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT*
    
- 디비 락에 대해 설명해주세요
    - lock은 어떠한 충돌하는작업(동시에 하나의 데이터를 수정한다든가)을 막기위한 개념
    - DB Lock은 작업이 완료될 때까지 다른 트랜잭션이 현재 작업 중인 데이터를 변경할 수 없도록 하는 "방해 금지" 표시와 같다
    - **공유락**(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다.
    - **베타락**(LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.
- Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
    - RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
    - 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 역색인을 지원해서 매우 빠르다는 특징을 가짐
- 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.
    - 옵티마이저는 SQL을 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
- DB 튜닝(Tuning)이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요.
    - DB 튜닝이란 DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말합니다.
    - 튜닝은 DB 설계 튜닝 → DBMS 튜닝 → SQL 튜닝 단계로 진행할 수 있습니다.
    - 1단계 - DB 설계 튜닝(모델링 관점)
        - DB 설계 단계에서 성능을 고려하여 설계
        - **튜닝 사례** - 반정규화, 분산파일배치
    - 2단계 - DBMS 튜닝(환경 관점)
        - **튜닝 사례** - Buffer 크기, Cache 크기
    - 3단계 - SQL 튜닝(App 관점)
        - SQL 작성 시 성능 고려
        - **튜닝 사례** - Hash / Join
- 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요.
    - Replication은 말 그대로 복제라는 의미다. 여기서는 데이터베이스 스토리지를 복제하는 것을 의미한다.
    - Clustering은 단순히 데이터베이스 서버를 확장한 것이라면 Replication은 데이터베이스 서버와 스토리지 모두를 확장하게 된다.
    - 클러스터링 (동기)
        - 디비 서버가 늘어나는게 클러스터링이다. 부하가 분산되니 CPU와 Memory도 부하가 줄어들게 된다.
        - 서버하나가 죽더라도 다른 서버로 서비스를 제공할 수 있다 ( 고가용성 )
    - 리플리케이션 (비동기)
        - 데이터변경은 master에게 데이터 조회는 slave가 처리한다
        - Master에서 Slave로 비동기 방식으로 데이터를 동기화 하기 때문에 일관성있는 데이터를 얻지 못할 수 있다.
        - 동기방식으로 Replication을 할 수 있지만 이럴 경우 속도가 느려진다는 문제점이 있다.
        - Master 서버가 다운이 될경우 복구 및 대처가 까다롭다는 단점이 있다.
- JOIN에서 ON과 WHERE의 차이를 설명해주세요.
    - **ON**이**WHERE**보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코들간 JOIN이 이뤄진다)
    - WHERE은 JOIN 을 한 후에 필터링을 합니다. (=JOIN을 한 결과에서 WHERE 조건절로 필터링이 이뤄진다)
- 디비에서 동기/비동기의 차이를 블럭/논블럭과 함께 설명하세요
    
    동기: 요청-결과가 동시에 일어난다는 것 (이때 답을 받을때까지 아무것도 할 수 없어서 블록 상태가 됨)
    
    비동기: 요청-결과가 동시에 일어나지않음 (답을 받을때까지 이것저것 할 수 있다. 논블럭상태라고 한다)
    
- 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요
    - 데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.
    - 일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.
    - 일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다. 또한 인덱스를 저장하기 위한 공간이 추가적으로 필요합니다
    - Index는 데이터베이스 테이블의 검색 속도를 향상해주기 위한 자료구조입니다.
    일반적으로 Index에 비유되는 예가 책의 색인 혹은 목차입니다.
    Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성할 수도 있습니다
- ACID에 대해서 설명해주세요.
    - 트랜잭션이 안전하게 수행됨을 보장하기 위한 성질을 가리키는 약어
    - Atomicity(원자성)
        - 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션 내의 모든 연산은 실패해야 합니다.
    - Consistency(일관성)
        - 트랜잭션은 유효한 상태로만 변경될 수 있습니다.(제약조건을 만족시키는 한에서 변경이 가능함을 의미)
    - Isolation(고립성)
        - 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
    - Durability(내구성)
        - 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)
- 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
    - READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.(잘안사용)
    - READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다.
    - REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.
    - SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.
    (성능 매우 떨어짐)
- 정규화에 대해서 설명해주세요.
    - 중복된 데이터를 최소화하게 데이터를 구조화하는 과정을 말합니다
    - DB의 저장 용량줄일 수 있다
- 제1정규화, 제 2정규화, 제 3정규화, BCNF 정규화 설명
    - 제1정규화
    - 컬럼이 하나의 값만 갖도록

    - 제 2정규화
        - 제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.
        - 여기서 완전 함수 종속이라는 것은 기본키의 일부가 결정자이면 안됩니다.
        - 예를들어 성적을 결정하기 위해선 [학번, 과목코드]가 모두 필요하다. 둘 중 하나만으로는 어떤과목에 대한 학생의 성적을 결정할 수 없다. 그러므로  성적은 [학번, 과목코드]에 ***완전 함수적 종속***이다. < 즉, 어떤 요소를 결정하는데 기본키의 일부만 쓰인다면 완전함수적 종속을 만족하지 않는것이라고 할 수 있습니다.
        - 기본키: 테이블 row의 고유 식별자
        - X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때,
        **Y는 X에 함수적 종속**이라고 합니다. 
        이 경우 **X를 결정자**, **Y를 종속자**라고 합니다. 
        **X→Y**
        
        !https://blog.kakaocdn.net/dn/ylbaZ/btqT8Jc4K3s/0VFTPoKKFkbxZghKWDwKo1/img.png
        
        - 이 테이블에서 기본키는 (학생번호, 강좌이름)으로 복합키이다. 그리고 (학생번호, 강좌이름)인 기본키는 성적을 결정하고 있다. (학생번호, 강좌이름) --> (성적)
        - 그런데 여기서 강의실이라는 컬럼은 기본키의 부분집합인 강좌이름에 의해 결정될 수 있다. (강좌이름) --> (강의실)
        - 즉, 기본키(학생번호, 강좌이름)의 부분키인 강좌이름이 결정자이기 때문에 위의 테이블의 경우 다음과 같이 기존의 테이블에서 강의실을 분해하여 별도의 테이블로 관리하여 제2 정규형을 만족시킬 수 있다
            
            !https://blog.kakaocdn.net/dn/bluCnc/btqT7VEOf04/Me8DfY7rtycgJPYlYQKEWK/img.png
            
    - 제 3정규화
        - 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
        - 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다.
            
        - 기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다.
        - b의 변경이 c의 변경또한 이루어져야하는데 이를 수동으로 처리해주어야한다. 이 불편함때문에 이행적 종속을 없애는것이다.
        - 이행적 종속을 제거하는 이유는 비교적 간단하다. 예를 들어 501번 학생이 수강하는 강좌가 스포츠경영학으로 변경되었다고 하자. 이행적 종속이 존재한다면 501번의 학생은 스포츠경영학이라는 수업을 20000원이라는 수강료로 듣게 된다. 물론 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것이다.
    - BCNF 정규화
        - 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
        - 후보키: 튜플을 **유일하게 식별할 수 있는 속성, 기본키로 선택될 수 있는 후보들을 의미**
        
        - 특강수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키 (학생번호, 특강이름)는 교수를 결정하고 있다. 또한 여기서 교수는 특강이름을 결정하고 있다.
        - 그런데 문제는 교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니라는 점이다. 그렇기 때문에 BCNF 정규화를 만족시키기 위해서 위의 테이블을 분해해야 하는데, 다음과 같이 특강신청 테이블과 특강교수 테이블로 분해할 수 있다.
            
- JOIN정의, 조인알고리즘 종류 대해 설명하세요
    - **조인이란 두 개 이상의 테이블을 하나의 집합으로 만드는 연산**이다
    - 조인알고리즘 종류
        - Nested Loops Join(중첩 루프 조인)
            - 한 테이블의 각 행을 반복하고 다른 테이블의 해당 행과 일치시키는 방식으로 작동합니다.
        - Merge Join(병합 조인)
            - 두 테이블을 각각 조건에 맞게 먼저 읽는다.
            - 그리고 읽은 두 테이블을 조인 컬럼을 기준으로 정렬해놓고, 조인을 수행한다.
        - Hash Join(해쉬 조인)
            - **테이블 중 하나를 해시 테이블로 선정**하여 조인될 테이블의 조인 키 값을 **해시 알고리즘**으로 비교하여 매치되는 결과값을 얻는 방식
- 낙관적락과 비관적락의 차이
    - 낙관적락은 충돌이 발생하지 않을거라고 가정하고 작업을 진행하는걸 말하구요(트랜잭션 커밋시에 충돌을 알게됨)
    - 비관적 락은 충돌이 발생할것으로 가정하고 일단 락을 걸고 보는 방식이다

- 클러스터 인덱스 vs 논클러스터인덱스
    - 클러스터 인덱스
        - 물리적으로 정렬된 상태
        - 기본적으로 대부분의 dbms에서는 pk를 가지고 클러스터 인덱스를 만듦
    - 논클러스터인덱스
        - 데이터는 정렬되지 않았지만 데이터를 참조하는 페이지가 정렬되어있다고 보면 됨
    
    → 클러스터 인덱스는 데이터 위치를 바로 알기 때문에 그 데이터로 바로 접근할 수 있고, 넌 클러스터 인덱스는 인덱스 페이지를 한번 거쳐서 데이터에 접근하는 방식이다.
    
- **테이블 파티셔닝이란?**
    - table을 파티션이라는 단위로 나누어 관리하는 기법
    - 파티셔닝을 언제사용할까?
        1. **대형 테이블**: 테이블이 매우 큰 경우 쿼리 속도가 느려질 수 있습니다. 파티셔닝은 데이터베이스 시스템이 전체 테이블이 아닌 관련 파티션만 스캔하도록 하여 성능을 향상시키는 데 도움이 될 수 있습니다.
        2. **빈번한 대량 로드 및 삭제**: 예를들어 날짜별로 테이블을 파티셔닝하고 날짜별로 날리고 추가하는 경우에 편함
        3. 
    
    파티셔닝은 일반적으로 DB 테이블을 작은 부분으로 여러 개 나누는 것을 의미합니다.
    
    파티셔닝은 열에 대해서 수직으로 혹은 행에 대해 수평으로 나누는 두 가지 방법이 존재합니다.
    
    - 종류
        - 수평 파티셔닝
            - 하나의 테이블안에있는 데이터를 두개의 테이블로 나눠 저장하는 방법
            - “샤딩”이라고도 불린다
            - 샤딩은 각 DB 서버에서 데이터를 분할하여 저장하는 방식이다. 해당 데이터에 접근할 때는 샤딩키를 사용하여 동적으로 DB 서버를 매핑하는 과정이 필요하다.
            - 샤딩은 일반적으로 DBMS가 지원하는 기능이 아니다. 그래서 ORM을 사용하거나 DB에 접근하는 서버에서 구현해주는 작업이 필요하다.
        - 수평 파티셔닝의 장점
            - DB 트래픽을 분산할 수 있는 중요한 수단이다.
            - 특정 DB의 장애가 전면 장애로 이어지지 않게 하는 역할도 한다.
        - 수평 파티셔닝의 단점
            - 샤딩은 실제 구현이 복잡하다. 잘못 수행하면 **데이터가 손실되거나 테이블이 손상되거나 부하의 불균형** 등이 발생할 수 있다. 이를 **샤딩 전 원래 DB 구조로 되돌리는 작업은 매우 복잡**하고 어렵다.
        - 수직 파티셔닝
            - 테이블의 일부열을 빼내는 형태로 구현
        - 수직파티셔닝의 장점
            - 자주 사용하는 컬럼 등을 분리시켜 성능을 향상시킬 수 있다.
            - 한 테이블을 SELECT하면 결국 모든 컬럼을 메모리에 올리게 되므로 필요없는 컬럼까지 올라가서 한 번에 읽을 수 있는 ROW가 줄어든다. 
            이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.
- RDBMS vs NOSQL에 대해서 설명해주세요.
    - RDBMS(Relational Database Management System)
        - 데이터를 컬럼과 로우의 형태로 저장합니다.
        - 구조화 되어있기때문에 sql을 활용하여 질의가능
    - NOSQL(not only sql)
        - 자유로운 데이터 구조를 가질 수 있습니다
        - 데이터가 Key와 Value의 쌍으로 저장된다.
        - RDBMS에 비해 복잡도가 떨어져 많은 데이터 저장
        - NoSQL은 이름처럼 ***SQL***을 사용하지 않고 별도로 제공하는 API를 통해 데이터를 건들 수 있다
        - RDBMS는 관계형 데이터베이스 관리 시스템을 의미합니다.
        관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스입니다.
        - 또한 RDBMS는 관계를 맺고 모여있는 테이블들의 집합체로 이해할 수 있습니다.
        이러한 테이블 간의 관계에서 서로의 칼럼을 기준으로 Join이 가능하다는 게 RDBMS의 가장 큰 특징입니다.
        - NoSQL이란(Not Only SQL)의 비 관계형 데이터베이스로서 약자로 말 그대도 위에서 설명한 RDB 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하고 있습니다.
        - **NoSQL에서는 RDBMS와는 달리 테이블 간 관계를 정의하지 않습니다. 관계 정의가 없으니 Join이 불가능하고 트랜잭션을 지원하지 않습니다.**
        - NoSQL은 데이터와 트래픽이 너무 클때 스케일업대신 선택할 수 있습니다.(비용문제측면에서) 대신.. 데이터 일관성은 포기하되 비용을 고려하여 여러 대의 데이터에 분산하여 저장하는 Scale-Out을 목표로 등장하였습니다.
    - nosql이 scale out하기에 좋게 설계되었다면서.. 어떤 설계가 scale out하기 좋은 설계지?
        - NoSQL 데이터베이스는 처음부터 데이터가 여러 서버 또는 노드에 분산될 수 있는 분산 시스템에서 작동하도록 설계되었고 여러 기능을 지원함
    - ㄴㄴ
    
    * 사전 지식
    
    - Scale-Up : 하드웨어를 변경하여 시스템의 성능을 높임
    => 비용이 많이 발생
    - Scale-Out : 하나의 장비에서 처리하던 일을 여러 장비에 나눠서 처리함 => 비교적 저렴한 방식으로 서버 유지 가능
- Redis에 대해서 간단히 설명해주세요.
    - "key-value" 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터베이스 (nosql) 관리 시스템이다.
- Redis와 Memcached의 차이에 대해서 설명해주세요.
    - 둘다 “key-value" 구조의 비정형 데이터를 저장하고 관리하기 위한 비관계형 데이터베이스 관리 시스템 입니다
    - Redis는 다양한 자료구조(리스트 등)를 지원하고, Memcached는 문자열 형태로만 저장합니다.
    - Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원합니다
    - 둘다 인메모리 저장소여서 컴퓨터가 꺼지거나하면 데이터가 날라갈 위험이 있다. 하지만 레디스는 디스크에 데이터를 백업해주는 기능이 추가로 있어서 데이터 유실의 걱정이 적다
- Elastic Search에 대해서 간단히 설명해주세요.
    - Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다
    - 방대한 양의 데이터를 신속하게 저장, 검색, 분석할 수 있습니다.
    - RDBS에서 인덱싱을 활용하면 검색성능을 향상시킬 수 있듯이 엘라스틱 서치는 이러한 인덱싱에 특화되어있습니다.
- MongoDB에 대해서 간단히 설명해주세요.
    - **JSON 개체와 유사한 document를 사용하여 데이터를 저장합니다**
    - 여기서 document란 key-value 쌍으로 이루어진 데이터 구조를 말합니다
    - RDB에 있는 조인을 비슷하게 흉내낼 수 있다
- 커넥션풀이란?
    - 디비와 연결을 하려면 커넥션을 얻어야한다
    - 커넥션 풀이란 DB와 미리 연결해놓은 connection들을 pool에 저장해두고,
    - 클라이언트 요청이 오면 connection을 빌려주었다가 사용이 끝나면 반납하는 방식을 의미합니다. DB connection이 많은 시간이 소요되고 불필요한 connection 연결과 해제를 할 필요가 없어 성능 상의 이점이 있습니다.
- sqlmapper vs orm
    1. SQL Mapper
        
        object와 sql문을 매핑하는 기술
        
    2. ORM
        
        Object와 DB테이블을 매핑하여 데이터를 객체화하는 기술
        
- jpql vs sql
    - JPQL엔티티 객체를 대상으로 쿼리한다.SQL은 데이터베이스 테이블을 대상으로 쿼리한다.
- **em.flush란?**
    - 영속성 컨텍스트의 변경 내용을 DB 에 반영하는 것을 말한다.
    - 이것을 해도 1차캐시의 내용은 비워지지 않는다
    - 1차 캐시의 내용을 비우는 em.clear()가 필요하다
- Persistence Framework란?
    - 데이터를 가공하는 자바 <-> 데이터를 저장하는 디비 층을 연결해주는 매개체
    - sql mapper와 orm이있다.
- 인덱스의 자료구조에는 어떤것들이 있나요?
    - 인덱스의 구현을 위해서는 대표적으로 B+트리와 해쉬테이블이 이용됩니다.
    - 해쉬 테이블은 (데이터, 데이터의 위치)를 (key, value)로 하여 해시를 생성합니다.
    - B+ 트리는 범위 쿼리 및 정렬된 데이터에 효율적입니다. 해시 테이블은 특정 데이터 조각을 찾는 데 매우 빠르지만 순서를 유지하지 않으며 범위 쿼리에 효율적이지 않습니다
- Table Full Scan과 Index Range Scan의 차이
    - 전자는 조건에 만족하는 데이터를 찾기위해 모든 row를 스캔해야한다면
    - 후자는 조건에 만족하는 데이터를 인덱스에 의해 정렬되어있어서 빠르게 찾을 수가 있어
- SQL injection이란?
    - 해커에 의해 조작된 쿼리문이 DB에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법입니다.
    - 주로 사용자가 입력한 데이터를 제대로 필터링하지 못했을 경우에 발생합니다.
    - HTTP1: 각요청에 대해 새 연결을 열어서 비효율적일 수 있습니다
    요청과 응답을 순서대로 하나씩 처리합니다. 하나의 요청이 막히면 그 뒤의 모든것들이 기다려야합니다
    - HTTP2: 여러 요청에 대해 하나의 연결만 사용하여 여러 요청과 응답을 병렬로 보냅니다.
    여러 요청과 응답을 동시에 처리하니까 하나가 막히더라도 다른 요청을 진행해서 효율적입니다.


# 자바
- **JVM이란 무엇인가?**
    - 자바가상머신을 부르는 말
    - 자바 애플리케이션을 실행하는 가상컴퓨터같은 개념입니다.
    - JVM이 있는 모든 시스템에서 자바코드를 실행중인 CPU가 이해할수있도록 해석해줍니다
- JVM이 하는일
    - 소스 코드는 바이트 코드로 컴파일이 되는데 JVM은 런타임 시 이 바이트 코드를 특정 OS에 맞게 조정된 기계어로 해석해줍니다
    - 메모리할당 및 가비지 컬렉터 작업을 수행합니다. 더이상안사용되는 것들을 메모리에서 지웁니다
- JAVA와 C의 차이
    - C언어를 예로 들어봅시다 .C로 된 파일이 있다면 OS마다 다른 컴파일러가 존재하고 그에 따라 다른 실행파일이 만들어집니다. 이 다른 실행파일들은 서로 다른 OS에서만 실행될 수 있습니다. 즉, 컴파일한 파일, 실행파일만 가지고는 서로 다른 OS에서 실행시킬 수 없다는 의미입니다. .C 파일을 받아서 새로 컴파일하고 새로 실행파일을 만들어주어야합니다하지만 JAVA는 하나의 .JAVA파일을 컴파일한 .CLASS파일을 어느 OS에서든 실행시킬 수 있죠
    - JAVA는 OS에 종속적이지 않습니다. 어느 JVM에서나 동작시킬 수 있죠하지만 JVM은 OS에 종속적입니다. 리눅스에서깔수있는 JVM이 있고, 윈도우에 맞는 JVM이 있죠
- jvm의 동작방식
    1. 운영체제로부터 메모리를 할당받습니다
    2. 자바 컴파일러가 .JAVA->.CLASS(바이트코드)로 컴파일합니다
    3. Class Loader가 1번에서 할당받은 메모리중 일부 영역에 Runtime Data Area로 클래스를 로딩한다.클래스가 가지고 있는 여러 부분들을 적당한 영역에 배치한다
    4. 로딩된 .class들은 실행엔진을 통해 해석된다
- **OOP(Object Oriented Programming) 란?**
    - 프로그래밍에서 필요한 데이터를 추상화시켜 행위(Method)와 상태(Attribute)를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
    - OOP의 4가지 특징(캡 상추다)으로는 캡슐화, 상속, 추상화, 다형성이 있다.
- OOP의 특징 4가지
    - 캡상추다
    - 캡슐화: 객체의 속성과 행위를 클래스 안에 넣고, 실제 구현 내용 일부를 내부에 감추어 은닉
    - 상속: 상위개념이 가지고 있는 변수, 메서드를 하위 개념이 물려받는것
    - 추상화: 객체들의 공통적인 특징(속성,기능)을 모아 하나의 클래스로 다루는것
    - 다형성: 하나의 타입으로 여러가지 참조변수를 사용할 수 있는 것
- 추상(abstract) 메서드 , 추상클래스에 대해 설명해주세요
    - **추상메서드** : 자식클래스에서 반드시 오버라이딩 해야하는 메서드
    - **추상클래스** : 하나 이상의 추상 메소드를 포함하는 클래스
        - 추상 클래스는 동작이 정의되어 있지 않은 추상 메소드를 포함하고 있으므로, 인스턴스를 생성할 수 없습니다. 추상 클래스는 먼저 상속을 통해 자식 클래스를 만들고, 만든 자식 클래스에서 추상 클래스의 모든 추상 메소드를 오버라이딩하고 나서야 비로소 자식 클래스의 인스턴스를 생성할 수 있게 됩니다.
- **instanceof 연산자는?**
    - 형변환이 가능한지 불가능한지 여부를 boolean으로 알려줍니다
- 인터페이스가 무엇? 목적
    - 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것
    - 인터페이스는 특정 개체가 수행해야하는 목록을 정의해놓은 명세서라고 보면 됩니다
    - 인터페이스를 통해 서로 다른 클래스간에 공통된 규격을 만들 수 있습니다. 그렇게 되면 유지관리가 쉬워집니다. 매번 A라는 부품을 만들기 위해 b,c,d가 필요하다는것을 알려주지 않아도 되니까요. A라는 인터페이스를 사용하는 사용자에게 b,c,d가 필요함을 강제함으로써 자연스럽게 규칙이 지켜질 수 있습니다
- 인터페이스에서 사용되는 상수, 메서드, 정적메서드, 디폴트 메서드 의 의미를 설명해주세요
    
    ```java
    public interface 인터페이스명 {
    	//상수
    	타입 상수명 = 값;
    	
    	
    	//추상 메소드
    	타입 메소드명(매개변수, ... );
    	
    	
    	 //디폴트 메소드
    	default 타입 메소드명(매개변수, ... ){//구현부}
    	
    	//정적 메소드
    	static 타입 메소드명(매개변수) {//구현부}
    }
    ```
    
    - 상수 : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조해라 (절대적)
    - 추상메소드 : 가이드만 줄테니 추상메소드를 오버라이팅해서 재구현해라. (강제적)
    - 디폴트메소드 : 인터페이스에서 기본적으로 제공해주지만, 맘에 안들면 각자 구현해서 써라. (선택적)> 이미 운영되고 있는 시스템에서 추가 요건으로 인해 불가피하게 반영을 해야할 때 디폴트메소드를 쓰면 효과적> 추가요건에 대한 대처를 할 수 있도록 유연성을 확보
    - 정적메소드 : 인터페이스에서 제공해주는 것으로 무조건 사용 (절대적)
- **추상클래스와 인터페이스의 차이**
    - 추상클래스 : 추상 메서드를 선언하여 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스입니다. 그래서 미완성 설계도라고도 표현합니다.
    - 인터페이스 : 추상클래스가 미완성 설계도라면 인터페이스는 기본 설계도라고 할 수 있습니다. 인터페이스도 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성하고 클래스와 다르게 다중상속(구현)이 가능
    - 추상클래스는 인스턴스 변수라는 상태를 가질 수 있습니다
    인터페이스는 접근제어자가 public하나인데 반해서 추상클래스는 public, protected, private을 가질 수 있습니다
    - 추상클래스나 클래스 상속은.. IS - A "~이다".
    - 인터페이스는 HAS - A "~을 할 수 있는".
- 오버로딩과 오버라이딩의 차이
    - 오버로딩:  매개변수의 타입이나 수로 구분된 중복이름함수를 정의할 수 있는 것
    - 오버라이딩: 부모로부터 상속받은 매서드를 자식객체가 재정의할 수 있는 것
- final vs static 차이
    - final : 상수 값을 만들고 싶을 때(수정이 불가능하다는 의미)
    - static : 객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 활용한다.
    - static final : 모든 영역에서 고정된 값으로 사용하는 상수
    - final method: **오버라이딩을 금지**
    - final class: 상속금지
- 깊은복사와 얕은복사의 차이
    - 깊은복사 - 메모리에 실제 공간을 하나 더 만들어서 그 공간을 참조하도록 하는것
    - 얕은복사 - 원본객체를 그저 참조만 하는 것
- Runtime Data Area에 대해 설명해주세요
    1. 모든 스레드가 공유하는 가비지 컬렉터의 대상
        
        1) 메서드 영역 : 클래스 파일의 바이트 코드가 로드되는 곳 
        
        - 힙영역처럼 자주 가비지 컬렉터가 회수하진 않지만 더이상 사용되지 않는 클래스르를 언로드 하긴 함
        
        2) 힙영역 :  new로 생성된 모든것이 생성됨
        
    2. 스레드별로 할당되는 영역
        
        3) 스택 영역: 지역변수, 임시값, 실행되는 메서드
        
        4) pc레지스터: 현재 스레드를 가리키는 포인터 저장
        
        5) native method stack: 자바외 언어로 작성된 코드를 위한 메모리 영역
        
        - native라는 키워드가 붙으면 자바로 구현한 코드가 아니라는 얘기다
    - final과 static은 메서드 영역에 존재한다. 왜냐면 인스턴스 별로 할당되는 변수가 아니기때문에..
    
    ```sql
    //동적인 final은 힙에 할당된다
    public class Car {
        final int maxSpeed;
    
        public Car(int max) {
            maxSpeed = max;
        }
    }
    //정적인 final은 메서드영역에 저장된다
    public class MathConstants {
        public static final double PI = 3.14159;
    }
    ```
    
- 자바의 동적로딩 vs정적로딩에 대해 설명해주세요
    - 동적로딩
        - 프로그램을 실행할 때, 필요할 때마다 동적으로 메모리를 생성하고, 필요없는 메모리는 자동으로 메모리에서 소멸시킨다.
        - 필요한 기능만 메모리에 불러와 사용하기 때문에, 큰 프로그램도 작은 메모리에서 실행이 가능하다.
        - 프로그램의 실행 속도가 느려질 수 있다.
        - ex) 자바
    - 정적로딩
        - 프로그램을 실행할 때, 모든 실행파일이 메모리에 로드된다.
        - 모든 기능이 메모리에 존재하므로, CPU가 필요로하는 기능을 빠르게 메모리에서 가져와 사용할 수 있다.
        - 메모리를 많이 차지한다.
        - ex) c언어
- Static 키워드의 장단점
    - Static 변수는 메모리에 한번 할당되어 프로그램이 종료될 때 유지되는 변수입니다
    class내에 static 변수는 class간에 공유되어야할 변수를 선언할때 사용하며
    class내의 static method는 class의 인스턴스 변수를 내부에서 사용하지 않을 경우에 주로 사용합니다
    - static을 사용하게되면 매번 인스턴스를 생성하지 않아도 사용할 수 있어서 속도측면에서 이득을 볼 수 있습니다.
    - 그에 반해 다음과 같은 단점도 가지고있습니다.프로그램 종료시 까지 메모리에 공간을 차지한다는 것입니다.
    - 가비지 컬렉터는 heap만 관리하지 static영역은 자주 관리하지 않습니다. 그래서 프로그램 퍼포먼스에 악영향을 줍니다.
    - static이라는 키워드자체가 객체지향적이지 못합니다. 데이터들이 캡슐화되어야한다는 객체지향의 원칙을 위반합니다.
- 리플렉션이란?
    - 구체적인 클래스 타입을 알지 못해도 클래스의 메서드, 타입, 변수들을 접근할 수 있게 해주는 Java API
    - 힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API
- 리플렉션 장단점
    - 장점
        - 런타임 시점에서 클래스의 인스턴스를 생성한다
        - 접근 제어자와 관계 없이 필드와 메소드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다.
    - 단점
        - 캡슐화 저해
- 리플렉션은 언제 사용하는가?
    - 가령 사용자가 덧셈을 입력하고 싶다고 하면 덧셈에 관한 class를 사용해야하고, 뺄셈이라고 명령어를 입력하면 뺄셈에 대한 class를 사용해야한다고 가정하자. 이를 일반적으로 구현하려면 if-else문을 사용해야한다. 하지만 리플렉션을 사용하면 다음과 같은 일이 가능하다
    
    ```java
    String className = getUserInput();
    Class<?> clazz = Class.forName(className);
    Object operation = clazz.newInstance();
    
    ```
    
    - 즉, 리플렉션을 사용하면 사용자 입력이나 설정파일과 같이 런타임에야만 알 수 있는 정보를 가지고 인스턴스를 생성할 수 있습니다
    - 가령, Spring의 Bean Factory를 보면, @Controller, @Service, @Repository 등의 어노테이션만 붙이면 Bean Factory에서 알아서 해당 어노테이션이 붙은 클래스를 생성하고 관리해 주는 것을 알 수 있다. 개발자는 Bean Factory에 해당 클래스를 알려준 적이 없는데, 이것이 가능한 이유는 바로 리플렉션 덕분이다. 런타임에 해당 어노테이션이 붙은 클래스를 탐색하고 발견한다면, 리플렉션을 통해 해당 클래스의 인스턴스를 생성하고 필요한 필드를 주입하여 Bean Factory에 저장하는 식으로 사용이 된다.
- **제네릭(Generics) 이란**
    - 데이터의 타입을 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미
    - 자바에서 타입 체크는 보통 컴파일에 수행됩니다
    근데 만약 제네릭이 없으면 List나 Map과 같은 컬렉션 작업할때 타입 체크가 제한됩니다
    제네릭이 없으면 모든 유형의 객체를 넣을 순 있으나 어떤 유형의 개체로 List를 선언했는지 컴파일러가 모르므로 개체를 올바르게 사용하고 있는지 알 수 없습니다
    
    ```java
    List list = new ArrayList();
    list.add("a string");
    list.add(42);//런타임 오류!
    
    ```
    
    - 제네릭을 사용하면 컬렉션이 갖는 타입을 컴파일러에게 알려서 컴파일러는 컴파일시간에
    컬렉션을 올바르게 사용하고 있는지 알 수 있습니다
    - 그러니까 제네릭 덕분에 런타임 오류를 컴파일에 알릴 수 있게 됩니다
- **SOLID(객체 지향 5대 원칙)에 대해 설명하세요.**
    - SRP(단일 책임 원칙) - 1개의 클래스는 1개의 책임만 가져야 한다.
    - OCP(개방-폐쇄 원칙) - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
    - **L**SP(Listov Substitution Priciple): 리스코프 치환 원칙: 자식은 언제나 부모타입으로 대체될 수 있어야한다
    - ISP(인터페이스 분리 원칙) - **객체가 자신에게 필요한 기능만을 가지도록 제한하는 원칙**입니다. 불필요한 상속과 구현을 최대한 방지함으로써 객체의 불필요한 책임을 제거합니다
    - DIP(의존관계 역전 원칙) - 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙
- list vs map의 차이점
    - Map은 검색할 수 있는 인터페이스이고, 데이터를 삽일할 때 Key와 Value의 형태로 삽입되어, Key를 이용해서 Value를 얻을 수 있다. 데이터 순서를 보장하지 않고, Key값은 중복 허용 X , Value값은 중복 허용
    - List는 순서가 있는 Collection이고, 데이터 중복이 허용된다.
    - List와 Map의 차이점은 List는 데이터 순서를 보장하지만, Map은 순서를 보장하지 않는다.
- 자바는 멀티스레드를 지원하는데. .  **멀티 스레드(Multi Thread) 사용할때의 장점은?**
    - 멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적다.
    - 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아진다.
    - 단점: 둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드 블록(임계영역)에 관한 문제가  추가적으로 생길 수 있습니다.
- 직렬화란?
    - Java에서 입출력할 때는 스트림이라는 데이터 통로를 통해 이동한다.
    - 객체를 바이트로 변환하여 네트워크 송수신이 가능하게 하는 과정이 직렬화입니다
    - 역 직렬화 : 네트워크로 전송받은 바이트 데이터 -> 객체

# JPA

- sql중심적인 개발의 문제점
    - 지루한 코드의 무한 반복
        - 기능 하나 추가해서 테이블을 하나 만들더라고, CRUD 쿼리를 다 짜야한다.
    - 객체 지향과 관계형 데이터베이스 간의 패러다임 불일치
        - 관계형 DB는 데이터를 잘 정규화해서 보관하는 것이 목표
        - 객체는 속성과 메서드로 잘 캡슐화해서 사용하는 것이 목표
        - 패러다임이 안맞는 객체를 관계형 DB에 넣으려하다보니 여러가지 문제가 생김
    - 객체 그래프 탐색에서의 **문제**
        - 마음껏 탐색할 수 없음. 내가 join을어디까지 했냐에 따라 탐색이 안될 수도 있음
    - “비교하기” 에서의 차이
        - 일반적인 SQL을 사용해서 두번 조회시, 반환되는 객체 두개는 ==비교했을 때 다르다
- 객체와 관계형 데이터베이스의 차이
    1. 상속 (객체에만 존재)
    2. 연관관계 (객체는 참조를 가지고 연관된 객체를 가져올 수 있음, DB는 PK와 FK로 조인해서 필요한 데이터 가져옴)
- 그래서 왜 jpa가 나온거야?
    - 객체를 자바 컬렉션에 저장하듯이 DB에 저장하고 싶은 목적때문에 나오게 됨
    
- jpa의 구동 방식
    - persistence에서 시작함 - META-INF/persisten.xml라는 설정정보를 조회한다
    - 그리고 EntityMagagerFactory를 만들고 필요할때마다 EntityManager를 생성한다
    

- EntityManagerFactory와 EntityManager
    - EntityManagerFactory는 DB당 하나씩만 생성된다. 애플리케이션 하나에서 공유한다.
    - EntityManager는 고객의 요청이올때마다 썼다가 버렸다가 한다
    - JPA는 스레드가 하나 생성될 때 마다(매 요청마다) EntityManagerFactory에서 EntityManager를 생성한다.
    - 스프링에서 EntityManager를 주입 받아서 쓰면, 같은 트랜잭션의 범위에 있는 EntityManager는 동일 영속성 컨텍스트에 접근한다.
    - 엔티티 매니저 내부에는 영속성 컨텍스트가 있으며, 이를 통해 엔티티 관리
    - 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유 가능??
    - EntitiyManager를 스레드간에 공유하면 안된다. 쓰면 버려야한다
    - 왜 스레드간에 em을 공유하면안되지?
        - 여러 스레드가 동일한 `EntityManager` 인스턴스를 공유하는 경우 데이터베이스에서 읽기 및 쓰기 작업을 동시에 수행할 수 있습니다.

- 엔티티의 생명주기
    - 비영속: 영컨에 있었던적이 없는 새로운 상태
    - 영속: 영컨에 의해 관리되는상태
    - 준영속: 영컨에 있었다가 분리된 상태
    - 삭제: 디비에서 삭제된상태
- 영속화된 entity의 특징
    - 같은 트랜잭션 안에서는 같은 id값이면 ==비교시 true가 뜬다
    
- 왜 굳이 트랜잭션 커밋시 db에 쿼리를날리는걸까? 바로바로 안하고?
    - 만약에 바로바로 db에 쿼리를 날리게 되면 최적화를 할 수가없다.
    - 불필요하거나 중복된 데이터베이스 쿼리 수를 줄일 수 있게된다
- 플러시가 발생하면 무슨일이 생길까?
    - 변경을 감지한다
    - 수정된 ENTITY에 대해선 UPDATE쿼리를 쓰기지연 SQL저장소에 넣어준다
    - 쓰기지연 SQL저장소에 있는 쿼리를DB로 전송한다
    - 1차캐시가 지워지진 않는다
    - 영속성 컨텍스트를 비우는것이 아니라 영속성 컨텍스트의 변경내역을 DB에 동기화하는것이다
- 영속성 컨텍스르를 flush 하는방법
    - commit시
    - em.flush()시
    - JPQL쿼리 실행시
- id생성전략 - identity에 대해 설명 (언제 insert쿼리가 날아가는가?)
    - 원래는 commit시점에 쿼리가 날라가는데 전략이 identity인 경우에만 em.persist를 한 동시에 쿼리가 날라가게 된다
    - 왜냐면 identity는 디비에 저장해야 pk값이 생기는건데 영속성 컨텍스트안에선 그럼 pk값이 뭔지 모르잖아 (db에 저장되기 전인)
- 연관관계의 주인을 정한다는 말의의미
    - 멤버의 team을 바꿨을 때 member의 team_id를 바꿀 것인가? team의 members가 바뀌었을때 member의 team_id를 바꿀것인가?
    - 보통은 객체의 두 관계중 하나를 연관관계 주인으로 지정(외래키가 있는 곳을)
    - 주인이 아닌 쪽은 읽기만 가능하다
    - 주인은 mappedBy 속성을 사용하지 않는다
    - 주인이 아니면 mappedBy 속성으로 주인을 지정한다
    
- 양방향 연관관계 setting시 양쪽에 값을 다 넣어줘야하는 이유
    - 원래는 fk하나로 연관관계가 결정되기때문에 한쪽에만 연관관계를 설정해도된다 그렇지만 디비에 저장하지 전까지 순수 객체 상태일 텐데 이 과정에서 연관관계에 맺어져있지만 아직 값이 들어가있지 않은 경우가 있을 수 있다(반대편에만 setting해서) 이를 고려해서 항상 양쪽에 값을 설정하자

- 일대일 관계에서는 unique컬럼을 필수로 등록해주어야한다
- ManyToMany를 지양해야하는 이유
    - 중간 테이블에는 매핑정보만 들어가고 추가 데이터를 넣는 것이 불가능하다. 에를들어 멤버랑 상품에 대한 중간테이블에는 멤버랑 상품을 매핑하면서 예를들어 상품구매시간 같은 추가 데이터를 못넣는다
    - 중간 테이블이 숨겨져 있기 때문에 쿼리가 예상하지 못하는 형태로 나간다.
- jpa에서 상속관계 매핑하는 법 3가지
    
    ### 조인전략

    - 앨범을 인서트 하면 아이템, 앨범에 두번 INSERT가 일어난다
    - 조회는 PK,FK로 수행한다
    - `ITEM-DTYPE`으로 이 아이템이 앨범인지 무비인지 북인지를 구분하는 컬럼을따로만든다
    
    ### 단일테이블 전략

    앨범, 책, 영화 각각이 가지는 컬럼들과 공통컬럼들을 그냥 모두 합쳐 하나의 테이블로 만든다
    
    그리고 이게 앨범인지 책인지 영화인지는 `DTYPE`을 통해 구분한다
    
- em.getReference이뭐야?
    - 디비조회를 미루는 가짜(프록시) 엔티티 객체를 조회하는거다
    - 디비 조회 쿼리 안날아감
    - 객체를 얻어낼땐 쿼리가 안날라가는데 .getId같이 호출을하면 그 시점에 select쿼리가 날라간다 그니까 해당 객체가 실제사용되는 시점에 쿼리를 날리는게 .getreference
- 프록시 객체특징
    - 실제 클래스를 상속 받아서 만들어짐
    - 실제 클래스와 겉 모양이 같다.
    - 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
    - 프록시 객체는 실제 객체의 참조(target)를 보관
        - 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출
    - 프록시 객체는 처음 사용할 때 한 번만 초기화
    - 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초
    기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
    - 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비
    교 실패, 대신 instance of 사용)
- n+1문제
    - 조회 시 1개의 쿼리를 생각하고 설계를 했으나 나오지 않아도 되는 조회의 쿼리가 N개가 더 발생하는 문제.
    - MEMBER 테이블 전체를 조회하면 MEMBER테이블조회쿼리한번, TEAM 테이블 조회쿼리 두번이 나간다. 해당 member에 맞는 team을 넣어줘야해요 그래서 member 객체에 들어가보면 team_id정보는 있는데 team객체는 없어요 그래서 select쿼리로 찾아야돼요 member 수만큼 찾게되니까 여러번의 쿼리가 나가요
- cascade(영속성전이), 개념, 언제사용가능한가?
    - 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속
    상태로 만들도 싶을 때
    - 이건 즉시로딩 지연로딩이랑 관계가 없는 개념이다
    - 소유자가 하나이고, 라이프사이클이 똑같을 때 쓸 수 있어
    
- jpa데이터타입을 분류해봐
    1. Entity타입
    • @Entity로 정의하는 객체
    • 데이터가 변해도 식별자로 지속해서 추적 가능
    • 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자(id)로 인식 가능
    2. 값 타입
    • int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
    • 식별자가 없고 값만 있으므로 변경시 추적 불가
    • 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

[https://www.inflearn.com/questions/158967/안녕하세요-entitymanager에-대해-궁금한-점이-있어-질문-남깁니다](https://www.inflearn.com/questions/158967/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-entitymanager%EC%97%90-%EB%8C%80%ED%95%B4-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%90%EC%9D%B4-%EC%9E%88%EC%96%B4-%EC%A7%88%EB%AC%B8-%EB%82%A8%EA%B9%81%EB%8B%88%EB%8B%A4)

- 스프링 컨테이너의 기본전략
    - **같은 트랜잭션 안에서는 여러 위치(여러 레포지토리)의 엔티티 매니저를 사용해도 항상 같은 영속성 컨텍스트에 접근**한다.

    - **트랜잭션이 다르면 동일한 엔티티 매니저를 사용해도 다른 영속성 컨텍스트를 사용**
    - 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. -> **멀티 스레드 상황에 안전함**
    - 트랜잭션 AOP란?
        
        *대상 메소드를 호출하기 전에 트랜잭션을 시작, 대상 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료*
        
        *트랜잭션 커밋 시 영속성 컨텍스트 플러시 => 변경 내용 데이터베이스에 반영*
        
        *예외 발생 시 트랜잭션을 롤백 -> 이때는 플러시 호출 X*
        
    - 뷰계층에서는 transactional 어노테이션 안사용하는이유
        - 애플리케이션 계층이 가지는 책임이 모호해짐
        - 유지보수성이 떨어진다.
        => 데이터가 어디서 어떻게 변했는지 프레젠테이션 계층까지 다 찾아야 함
    - 준영속 상태로 바꼈을떄의 단점
        - 뷰를 렌더링할 때 연관된 엔티티도 함께 사용해야 하는데 연관된 엔티티를 지연 로딩으로 설정해서 프록시 객체로 조회했다.
        - 초기화하지 않은 프록시 객체를 사용하면 실제 데이터를 볼러오기 위해 초기화를 시도한다.
        - 하지만 준영속 상태는 영속성 컨텍스트가 없으므로 지연 로딩을 할 수 없어 예외를 발생시킨다.
    - 위의 문제를 해결하는 방법(준영속으로바껴버려서 조회안되는문제)
        - FetchType.EAGER 사용
            - 사용안할것도 모두 불러올지도모름
            - n+1문제발생
        - JPQL 페치 조인으로 함꼐 가져오기
            - 무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가한다.
                - 프레젠테이션 계층이 알게 모르게 데이터 접근 계층을 침범하게 된다.
        - 강제로 초기화
            - 하지만 이렇게 서비스 계층은 비즈니스 로직을 담당해야지, 프레젠테이션 계층을 위한 일까지 하는 것은 좋지 않다.
            - 이렇게 서비스 계층이 프레젠테이션을 위한 일까지 하면 뷰에서 필요한 엔티티에 따라 서비스 계층의 로직이 바뀌어야한다.
            - 따라서 서비스 계층에서 프레젠테이션 계층을 위한 프록시 초기화 역할을 분리하고, 그 역할을 `FACADE 계층`이 담당해준다.
            - facade란?
                
                ```java
                class OrderFacade {
                    @Autowired OrderService orderService;
                    public Order = orderService.findOrder(id);
                    // 프레젠테이션 계층이 필요한 프록시 객체를 강제로 초기화
                    order.getMember().getName();
                    return order;
                }
                class OrderService{
                    public Order findOrder(id){
                        return ordeRepository.findOrder(id);
                    }
                }
                ```
                
                - 중간에 계층이 하나 더 생겨버린다. 즉 더 많은 코드를 작성해야 한다. -> 번거로움!
                - 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많을 것이다.
                - 화면별로 최적화된 엔티티를 딱딱 맞아떨어지게 초기화해서 조회하려면 여러 종류의 조회 메소드가 필요하다.
        - OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법
            - **뷰에서도 지연 로딩을 사용할 수 있도록 하는 것**
        
    - osiv의 과거방식 + 필요성 + 단점
        - 필요성:
            - 결국 모든 문제는 엔티티가 프레젠테이션 계층에서 준영속 상태이기 때문에 발생한다.
            - 따라서 **영속성 컨텍스트를 뷰까지 열어둠으로써 뷰에서도 지연 로딩을 사용할 수 있다.**
        - osiv의 과거방식
            - 클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 만들면서 트랜잭션을 시작하고, 요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 끝내는 방법
            이렇게하면 영속성 컨텍스트가 처음부터 끝까지 살아있으므로 조회한 엔티티도 영속 상태를 유지한다. -> **뷰에서 지연 로딩이 가능**하므로 엔티티를 미리 초기화할 필요 X, `FACADE 계층` 없이도 뷰에 독립적인 서비스 계층을 유지할 수있다.
            
        - osiv과거방식의 단점
            - 컨트롤러나 뷰 같은 프레젠테이션 계층이 엔티티를 변경할 수 있다.
        - osiv과거방식의 단점의 해결책
            - 위와 같은 문제를 해결하려면 프레젠테이션 계층에서 엔티티를 수정하지 못하도록 막으면 된다.
                - 엔티티를 읽기 전용 인터페이스로 제공
                - 엔티티 레핑
                - DTO만 반환
- 스프링이 제공하는 osiv는 기존 osiv의 어떤 단점을 보완했나?
    - 스프링이 제공하는 OSIV를 사용하면 프레젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다. -> 기존 OSIV의 단점 보완
    - 영속성 컨텍스트를 프레젠테이션 계층까지 유지
    - 프레젠테이션 계층에는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.
    - 프레젠테이션 계층에는 트랜잭션이 없지만 트랜잭션 없이 읽기를 사용해서 지연 로딩을 할 수 있다.
    - 컨트롤러에서 엔티티 수정 후 즉시 뷰를 호출하는 것이 아니라 트랜잭션이 동작하는 비즈니스 로직을 호출해서 발생하는 문제 → set자체는 가능함. biz로직 호출했을때 error가 터짐
    - 그러니까 biz로직 호출끝나고나서 set하면 error안남
    - 
    
- 스프링 osiv의 장점
    - OSIV를 사용하면 영속성 컨텍스트가 프레젠테이션 계층까지 살아 있어 미리 초기화할 필요가 없다.
    - **따라서 단순한 엔티티 조회는 컨트롤러에서 레포지토리를 직접 호출해도 아무런 문제가 없다!**
    
- spring.jpa.open-in-veiw = "true”을 설정하면?
    - osiv가켜진다. osiv가 켜진다는것은 다음을 의미한다
    1. Hibernate는 각각의 HTTP 요청에 대해 영속성 컨텍스트를 자동으로 열고, 응답이 완료될 때까지 영속성 컨텍스트를 유지합니다.
    2. View 계층에서 엔티티의 데이터를 사용할 때, Hibernate는 해당 데이터에 대한 지연로딩을 실행하고 필요한 데이터를 로딩합니다. 이는 OSIV 패턴이 지연로딩과 지연초기화 문제를 해결하는 데 도움을 줍니다.
    3. 트랜잭션 범위도 확장됩니다. 즉, Controller 계층에서 엔티티에 대한 변경이 이루어지면, 영속성 컨텍스트가 열려있는 상태에서 이루어지며, 이 변경은 트랜잭션 커밋 시점에 반영됩니다.
- 그냥 jpql사용하면 되잖아 왜 영속성 컨텍스트를 확장하는거야?
    - 너무 무분별하게 사용하면 뷰와 리포지토리사이의 논리적인 의존관계가 생긴다
    - 예를들어 다음과 같은 상황이있다고 가정하자
    1. 회원 A를 위해 order만 조회하는 메서드
    2. 회원 B를 위해 order과 delivery를 조회하는 메서드
    - → 이 경우 각각 두개 만드는것보단 하나로 합친다음에 1번이 좀더 느려지더라도 order만 빼서 사용하면 된다 너무 의존성이 심해지는것보단 이게 낫다.
    
- “트랜잭션 없이 읽기”에 대해 설명해보세요
    - 영컨은 트랜잭션 범위 안에서만 변경이 가능하다
    - 영컨은 트랜잭션 범위 밖에서도 조회를 할 수 있다 < “트랜잭션 없이 읽기”
- 만약에 비즈니스 계층 트랜잭션 osiv를 사용했는데, controller에서 entity를 변경하면 무슨일이 일어나나?
    - 영컨의 변경내용을 반영하려면 flush()가 호출돼야하는데 트랜잭션 범위내에 있지않아서 flush가 안됨
    - flush를 강제로 해주려고 해도 트랜잭션 범위가 아니여서 실패
    - 
- osiv가 뷰에서도 지연로딩이 가능하게 하려고 도입한거잖아요 (뷰에서 필요한값들을 지연로딩으로 가져오려고)
근데 지연로딩을 하면 결국 필요없는 쿼리가 추가로 나가게될텐데..애초에 필요한 데이터만 jpql사용해서 뽑아서 주면 문제가 해결되는거아닌가요? 왜osiv를 사용하는거죠?? 뷰와 리파지토리가 너무 연관되어서 그런가요..? 그게 그렇게 큰 단점인가요..?
    
    답변—
    
- osiv: 요청당 트랜잭션의 경우. biz()호출이후 setfield()를 호출하면 문제가 생긴다. 설명해보시오
    - 영속성컨텍스트의 범위내에 있기때문에 set을 하면 변경감지가 동작해서 값을 바꾸는 쿼리를 날린다. 그래서 문제가 생긴다
- 왜 osiv에서 프레젠테이션계층에서 biz() 호출 전에 setfield하면 error가 나는건가요?
왜 엔티티 수정 직후 뷰를 호출하면 이런 문제가 안생기나요?
    - 원래 영속성 컨텍스트내부에 있어서 변경감지가 일어나긴했는데 트랜잭션 범위밖이여서 update쿼리가 나가지않는거였는데, biz()에 들어가면서 트랱잭션 범위내에 들어가게된다. 그러면서 update쿼리를 생성하게된다. biz를 안거치기만 하면 해결된다. 마지막에 setfield를 사용하면 이 문제는 해결된다
- 동일성 비교, 동등성 비교
    
    동일성 비교 : 인스턴스의 참조 값을 비교, == 사용
    
    동등성 비교 : 인스턴스의 값을 비교, equals()사용
    
- 언제 임베디드 타입 을 사용해야할까?
    - 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것
    은 값 타입이 아닌 엔티티
    - 임베디드 타입은 변경감지에 영향을 받지않는다
    
- 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
    
    일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
    
    근데 일대다 같은 데이터 뻥튀기기 되는것들은 페이징을 할 수 없어
    
- jpql을 실행시켜서 결과를 받아왔는데 그 결과가 영컨에 있으면 자기가들고왔던것을 버린다. 왜그러는것일까?
    - 영컨은 영속상태인 엔티티의 동일성을 보장해주어야하기때문
- jpql 주의사항
    - jpql은 영컨 안 들르고 바로 디비에쿼리날리기때문에 jpql 실행전엔 항상 flush가 일어나야한다.
    - 기본설정은 auto로 jpql실행 직전에 플러쉬가 된다. 플러시모드는 우리가 따로 설정할 수 있다.
- 플러쉬모드:commit 이 필요한 상황
    1. 성능 향상:  이럴 때 COMMIT 모드로 설정하면 트랜잭션 커밋 시에만 플러시가 발생하므로 성능을 향상시킬 수 있습니다.
    2. 데이터 일관성 유지: 커밋이전까지는 다른 사용자가 해당 데이터를 조회하는 상황에서 커밋 이전의 내용을 보게 하고싶을때 commit모드를 사용할 수 있다
    
- 트랜잭션 aop에 대한 설명
    - 서비스 계층에 @Transactional 어노테이션이 붙어있으면 트랜잭션이 시작된다 근데 이 메서드 실행직전에 트랜잭션 aop가 먼저 동작한다
    - 스프링 컨테이너는 트랜잭션 범위의 영컨 적략을 기본으로 사용한다
    - 트랜잭션범위 == 영컨 범위 라는 얘기다
    - 트랜잭션이 같으면 같은 영속성컨텍스트를 사용한다
    - 엔티티매니저는 다른데 트랜잭션이 같아서 같은 영속성컨텍스트를 사용할 수 있다
    - 스프링컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 즉, 다른 스레드가 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 달라서 멀티스레드 상황에 안전하다
- 뷰에서 지연로딩하는 경우 프록시객체를 참조해서 error터질때의 근본적인 문제
    - 미리 로딩해두는방식은 별로다. 왜냐면 애플리케이션 로직과 뷰가 논리적으로 서로 의존하기때문이다.
- osiv의 변화과정
    - 요청 당 트랜잭션 → 비즈니스 계층 트랜잭션
    - 요청당트랜잭션: 요청 들어오자마자 영컨을 만들면서 트랜잭션도 시작
        - 컨트롤러/뷰 같은 프레젠테이션 계층이 엔티티변경가능해짐
    - 비즈니스계층트랜잭션: 요청들어오자마자 영컨생성 + 트랜잭션은 비즈니스 계층부터
- 스프링osiv의 특징
    - 요청이 들어올때마다 영컨 생성해서 요청이 끝날때까지 같은 영컨을 유지한다.
    - 같은 영컨을 여러 트랙잭션이 공유할 수 있다(트랜잭션 롤백시 주의 (15.1.4)
    
- 엔티티 그래프 관련 공부
    
    
- **JPA 표준 예외 정리**
    
    1) 트랜잭션 롤백을 표시하는 예외
    
    - 심각한 예외로 트랜잭션을 강제로 커밋해도 RollbackException 에러 발생
    
    2) 트랜잭션 롤백을 표시하지 않는 예외
    
    - 심각한 예외가 아니므로 개발자가 트랜잭션을 커밋할지 롤백할지 결정할 수 있음
# 운영체제
- 운영체제란 무엇인가요?
    - 하드웨어, 소프트웨어, 사용자를 매개하는 프로그램입니다
- 인터럽트에 대해 설명해주세요
    - cpu에게 이벤트 발생을 알리는것을 인터럽트라고 합니다
    - 인터럽트가 요청되면 운영체제는 작업을 멈추고 인터럽트 우선 처리 하고 나서 기존작업으로 돌아옵니다.
    - 이때 소프트웨어에 의해 발생되는 인터럽트를 트랩이라고 부릅니다
    - 하드웨어는 시스템버스를 통해 인터럽트를 발생시키고 
    소프트웨어는 시스템 콜을 통해 인터럽트를 발생시킵니다
    - 인터럽트벡터에는 인터럽트에 의해 찾아가야할 위치, 인터럽트를 처리할수있는 서비스 루틴의 주소가 들어있습니다
- 인터럽트 주도적 과 폴링에 대해 설명해주세요
    - 인터럽트가 발생하기 전까지 cpu가 대기 상태이고, 인터럽트가 발생하는 경우에 처리하는것이 인터럽트 주도적 방식입니다. 현대 운영체제는 인터럽트 주도적입니다.
    - 폴링은 이와 반대로 주기적으로 이벤트를 감시하는 방식입니다. 이렇게 되면 컴퓨팅 자원을 낭비하게 됩니다(이벤트가 발생하지 않은 상태에서도 주기적으로 감시를 해야하니까 자원낭비)
- DMA에 대해 설명해주세요
    - Direct Memory Access의 약자로 특정 하드웨어 시스템이 cpu를 거치지 않고 바로 메모리에 접근할 수 있게 해주는 기술입니다.
    - cpu의 할일이 줄어들어 성능이 향상되는 효과가 있습니다.
- 싱글프로세서시스템과 멀티 프로세서 시스템을 비교해주세요
    - 싱글프로세서는 하나의 cpu를 가지는 시스템을 말합니다
    - 멀티프로세서 시스템은 두개이상의 프로세서를 가지는 시스템을 말합니다
    - 프로세서가 늘어나니까 더 빠른 시간안에 연산을 수행할 수 있습니다.
    - 기능이 여러 프로세서에 분산되면 하나의 프로세서가 작동을 멈춰도 전체시스템은 느려질뿐 멈추지 않습니다.
    - 멀티프로세서는 비대칭 멀티 프로세싱과 대칭멀티프로세싱으로 나눌 수 있습니다
    - 비대칭 멀티프로세싱
        - 보스의 명령을 받는 방식으로, 부하 분산을 효율적으로 할 수 있습니다. 단, 보스가 멈추면 일꾼도 멈춤니다.
    - 대칭 멀티 프로세싱
        - 보스가 없는 자유로운 회사입니다. 모든 프로세서는 하나의 메모리를 공유하고 작업을 병렬적으로 수행합니다
        - 만약 하나의 프로세서에 문제가 생겨도 다른 프로세서에게 일을 넘기고 자신을재부팅합니다
- 멀티프로세서시스템과 듀얼코어시스템을 비교해주세요
    - cpu가 늘어나면 프로세서간 통신을 하는데 많은 비용이 들어서 효율이 계속 좋아지지 않습니다.
    - 멀티코어는 하나의 칩에 cpu를 여러개 늘리는것으로, 칩내부 통신이 칩 사이의 통신보다 더 빠르고 전력을 적게 사용해서 효율적입니다
- 클러스터시스템은뭐죠?
    - 여러개의 시스템(독립실행가능한 컴퓨터?)이 하나로 모여있는 구조를 말합니다
    - 하나의 저장소를 공유하고 이들을 LAN과같은 네트워크로 연결한 시스템을 클러스터 시스템이라고 부릅니다
    - 고가용성을 제공하기 위해 사용됨(하나의 노드가 문제가 발생해도 다른 노드가 작동할 수 있으니 고가용성)
    - 시스템의 성능이 네트워크 환경에 많은 영향을 받습니다.
- 멀티프로그래밍에 대해 설명해주세요
    - 여러 프로그램을 메모리에 로드해두고, 한 프로세스가 대기 상태가 되면 다른 프로세스의 작업을 수행하는 시스템 -> cpu 사용 효율을 높일 수 있다
- 멀티태스킹에 대해 설명해주세요
    - 시분할시스템
    - 프로세스마다 작업시간을 정해두고 번갈아가면서 작업
    - 사용자 입장에선 마치 동시에 작동하는것처럼 보임
- 멀티스레딩?
    - 하나의 프로세스가 동시에 여러 개의 스레드를 수행할 수 있도록 해주는 것이다.
    - 프로세스를 생성하는 비용보다 스레드를 생성하는 비용이 더 저렴하기 때문에 프로세스에 다수의 스레드를 생성하여 병렬처리하는 것이다.
    - 또한 스레드는 스택 영역을 제외한 데이터, 힙 영역을 서로 공유하기 때문에 메모리 부분에서도 훨씬 효율적이다.
- 작업스케쥴링(cpu스케줄링)에 대해 설명해주세요
    - 멀티태스킹이나 멀티프로그래밍이나 여러작업을 동시에 메모리에 올리는 방식이다
    - 메모리에 자리가 없을 경우를 대비해서 어떤 작업을 먼저 처리할지 정하는 과정
- 운영체제를 유저모드와 커널모드로 나누면 장점
    - 나쁜의도를 가진 사용자로부터 운영체제, 하드웨어를 비롯한 시스템과 사용자를 보호할 수 있다
    - 커널모드로 진입하려면 인증이 필요함
- 프로그램과 프로세스의 차이
    - 디스크에 있으면 프로그램이고 메모리에 로드되면 프로세스다
- 프로그램 카운터(PC)란?
    - 프로세스가 어디까지 실행되었는지를 북마크하는 것
- 타이머란?
    - 사용자의 프로그램이 제어권을 운영체제에게 넘겨주지 않을 경우를 방지하기 위해 timer를 사용한다
    - 특정주기에 인터럽트를 발생시킨다
- 캐시/캐싱이란?
    - 캐시: 빠르고 작은 저장장치
    - 캐싱: 캐시메모리를 사용해 컴퓨터의 속도를 높이는 기술
    - 데이터를 디스크에서 직접 가져오는것이 너무 느리기때문에 캐시에 자주사용될것같은 데이터를 미리 담아두고 cpu 캐시의 데이터를 참조할 수 있도록한다
- 캐시의 지역성원리에 대해 설명하시오
    - 공간지역성
        - 특정데이터와 가까운 메모리 주소에 있는 다른 데이터에 접근할 가능성이 높다
    - 시간지역성
        - 한번 접근한 데이터에 다시 접근할 확률이 높다
- 프로세스를 나눠보세요/프로세스의 구성
    - 프로세스는 Stack, Heap, Data, Code 로 나뉜다
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/93ab45d6-f90e-49b6-a95c-8e9e45cdc572/Untitled.png)
    

- 시스템콜이란?
    - 운영체제에게 어떤 기능(서비스)를 사용하게 해달라고 요청하는 방법입니다
- PCB란?
    - Process Controll Block
    - 프로세스 정보의 묶음(pc, 레지스터정보 등)
- 컨텍스트 스위칭이란?
    - 프로세스가 실행되다가 인터럽트가 발생해서 운영체제가 개입해서 프로세서에 할당된 프로세스를 바꾸는것
    - 오버헤드가 발생하는 작업.
    - 컨텍스트: 내 시스템에서 활용가능한 정보들
- IPC란?
    - InterProcess Communication
    - 프로세스는 독립적으로 동작하거나 협력할 수 있는데, 
    협력하는 프로세스들간의 통신을 말합니다.
    - 메세지패싱이나, 공유메모리 방식을 사용합니다
    - 메세지 패싱
        - 커널을 통해 정보를 전달하고 커널에 접근해 정보를 받는다
        - 메세지 패싱은 컨텍스트 스위치가 발생해서 속도가 느리다
        - 다만 커널이 기본적인 기능을 제공해서 구현이 공유메모리보다 쉽다
    - 공유메모리
        - 특정메모리 공간을 두 프로세스가 함께 사용하며 정보를 주고 받는다
        - 커널을 거치지 않아서 속도가 빠르지만, 메모리 동시접근을 막아야해서 따로 구현이 필요하다
- 생산자-소비자문제란?
    - 정보를 생산하는 프로세스와 소비하는 프로세스가 동시에 공유데이터에 접근할때 일어나는 이슈를 생산자-소비자 문제라고합니다
    - 이때 발생하는 동기화 문제를 버퍼를 사용해서 해결합니다(버퍼에있는걸쓰고 읽는)
        - 한번에 하나의 프로세스만 버퍼에 엑세스할수있도록함 < 이거덕분에 생산자-소비자문제를해결
        - 버퍼가있기때문에 쓰는 사람은 읽는사람을 기다리지 않고 버퍼에 쓰면돼서 버퍼를 이용하는듯
        
        운영체제의 생산자-소비자 문제에 관해 질문할것이 있는데요
        제가 설명한게 맞는지 궁금합니다
        
        생산자소비자문제: 생산하는프로세스, 소비하는 프로세스가 공유데이터에 동시접근 시 생기는 이슈를 말함
        
        - > 버퍼를 사용해서 해결
        -> 그런데 한번에 하나의 프로세스만 공유데이터에 엑세스 하는 등의 방식으로도 해결할수있는데 왜 굳이 버퍼를 사용하는가?
        - > 버퍼가 있다면 공유데이터에 무언가를 쓰려는 사람은 읽는사람을 기다리지 않고 버퍼에 계속 쓰면 돼서 더 효율적이기떄문인가요?
        - → 버퍼가 있다고 해결되는거 아님.. 버퍼가 있어도 상호배타 이런 조건들을 만족할수있게 따로 처리를 해야함.
- IPC방식중 하나인 메세지 패싱의 동기화 문제는 어떻게 해결해?
    - Blocking 방식
        - 보내는놈: 메세지를 보내고 받을때까지 기다린다
        - 받는놈: 메세지가 올떄까지 멈춰있음
    - non-blocking방식
        - 보내는놈: 메세지를 받건 말건 계속일함
        - 받는놈: 있으면받고 없으면 넘어감
- 소켓이란?
    - 서버와 클라이언트가 통신하는 방식이다
    - IP주소와 포트정보가 있으면 클라이언트는 네트워크를 통해 서버 프로세스에 접근할 수 있다
- RPC란?
    - (remote Procedure calls) 원격 프로시저 콜
    (원격으로..즉 네트워크로 특정 작업을 실행시킬수 있다는얘기)
    - 프로세스와 프로세스가 네트워크로 이어져있을때 발생하는 호출이다
- 파이프란?
    - 부모 프로세스와 자식프로세스가 통신할때 사용하는 방식이다
    - 프로세스사이에 파이프를 두고 정보를 두고받는방식으로, 단방향 통신만 가능하다
    - 양방향 통신을 하려면 두개의 파이프가 필요(파이프는 파일이다)
- 프로세스 여러개 돌리는거 말고 프로세스안의 스레드를 여러개 두는 이유는?
    - 두 프로세스가 하나의 데이터를 공유하려면 메세지 패싱이나 공유메모리 혹은 파이프를 사용해야하는데 효율이 떨어지고 개발자가 구현, 관리하기 번거롭다
    - 프로세스사이 컨텍스트 스위치가 계속일어나면 성능저하가 발생. 스레드전환에도 컨텍스트 스위치가 일어나지만 속도가 더 빠르다
- 멀티코어프로그래밍에서 동시성과 병렬성에 대해 설명해보세요
    - `동시성`:프로세서가 여러스레드를 번갈아가며 수행함으로써 동시에 실행하는것처럼 보이는 방식
    - `병렬성`: 멀티 코어에서 사용됨. 여러개의 코어가 각 스레드를 동시에 수행하는 방식
- 스레드 풀이 뭐죠?
    - 스레드를 요청할때마다 매번 새로운 스레드 생성, 수행, 지우기를 반복하면 성능이 저하된다
    - 미리 스레드풀에 여러개 스레드를 만들어두고 요청이 오면 스레드풀에서 스레드를 할당해주는 방식을 사용한다
- 디스패치가 무엇인가요?
    - 디스패치: 운영체제가 프로세스를 프로세서에 할당하는것
    - 이때 프로세스 상태가 Ready에서 Runing으로 바뀐다
- 프로세스 스케쥴링이란 무엇인가요?
    - 대기하는 프로세스들중에 어떤 프로세스를 프로세서에 할당할 것인가를 정하는 것을 말합니다

- 프로세스 스케쥴링의 종류에 대해 말해보세요
    - FCFS(First-Come, First-Served)
        - 먼저들어온 프로세스를 먼저 프로세서에 할당
        - 구현이 쉽다.
        - 프로세스 처리 순서에 따라 성능이 크게 달라진다
        - 수행시간이 큰 프로세스가 가장 먼저 들어오면 그 뒤의 프로세스들이 불필요하게 오랜시간을 기다려야하는 콘보이 효과가 발생
        - 먼저온 프로세스가 끝날때까지 운영체제가 개입하지 않는 비선점 스케쥴링 방식이다
    - SJF(Shortest Job First)
        - 프로세스의 수행시간이 짧은 순서에 따라 프로세서에게 할당
        - 앞서 발생하는 콘보이 효과 해결할수있다
        - 최적알고리즘이긴하지만 수행시간을 정확히 알 수 없다
        - 버스트 시간이 큰 프로세스는 계속 뒤로 밀려나는 기아가 발생
        - 비선점 스케쥴링 방식
    - SRF(Shortest Remaining Time First)
        - 프로세스의 남은 수행시간이 짧은 순서에 따라 프로세서에 할당
        - 앞서 말한 기아문제 어느정도 해결 가능
        - 수행 중 다른 프로세스가 남은 수행시간이 적어지면 운영체제가 개입해 자리를 바꾸는 선점 스케쥴링 방식
    - RR(Round Robin)
        - 일정시간 단위로 여러 프로세스를 번갈아가며 프로세서에 할당
        - 반응성이 좋다
        - 우선순위 스케쥴링과 결합해 프로세스의 시간 할당량을 조절 한다
        - 시간 할당량에 따라 운영체제가 계속 개입하는 선점스케쥴링 방식
    - Priority Scheduling
        - 우선순위에 따라 프로세서에 할당
        - 선점, 비선점 모두 가능
- 스케쥴링 알고리즘을 선점방식, 비선점방식으로 나눌 수 있는데 이 둘에 대해서 설명해주세요
    - 선점방식
        - 운영체제가 강제로 프로세스의 사용권을 통제하는 방식
    - 비선점방식
        - 프로세스가 스스로 다음프로세스에게 다음 자리를 넘겨주는 방식
- race condition(경쟁상태) 가 무엇인가?
    - 프로세스가 어떤 순서로 공유데이터에 접근하냐에 따라 결과값이 달라지는 상황을 경쟁상태라고 부른다
    - 올바른 결과
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e835690-e552-42c9-919c-cdf0e84a8b9f/Untitled.png)
        
    - 올바르지 않은 결과
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d0b7125-a705-43fa-adc9-c07429b82871/Untitled.png)
    
- Critical Section(임계구역)이란?
    - 코드상에서 경쟁조건이 발생할 수 있는 특정 부분
- critical Section 문제를 해결하는 방법 (아래를 모두 지켜야함)
    - 상호배제
        - 이미 한 프로세스가 Critical Section에서 작업중일때 다른 프로세스는 이곳에 진입해서는 안된다
    - 진행(Progress)
        - 아무도 critical section에 작업중이지 않다면 다른 프로세스는 들어올수있어야한다
    - 한정대기(Bounded waiting)
        - critical section에 진입하려는 프로세스가 무한하게 대기해서는 안된다
- critical section 문제를 해결하려고 상호배제를 구현하려고 한다. 
이때 어떤 방식을 사용해야 구현이 가능할까?
    - 여러 스레드 혹은 프로세스가 공통 리소스에 접근하는 것을 제어하는 기법입니다
    - 아래 두 방식 모두 여러 프로세스들에 의해 공유되는 변수로, 사용하고 있는 스레드 혹은 프로세스의 숫자를 관리해서 상호배제를 적용합니다
    1. 세마포어
        1. 예를들어 화장실이라는 공유자원이 세개가 있다고 가정. 사람들은 스레드혹은 프로세스라고 가정하자. 사람이 화장실에 들어가고 싶으면 빈칸의 개수를 확인하고 입장할때 혹은 나갈떄 화장실 개수에 변화를 줍니다 더하거나 빼서요. 이런식으로 공유자원 즉 화장실의 들어갈수잇는 여부를 관리하는것이 세마포어입니다. 세마포어는 이때 사용되는 숫자를 의미합니다. 
        뮤텍스와의 차이는 공유자원 개수의 차이죠. 뮤텍스는 오직 공유자원이 하나일때 사용할 수 있습니다. 즉, 화장실이 하나일때 사용가능하다는얘기입니다
        2. 동기화 대상이 하나 이상일때 사용한다
    2. 뮤텍스
        1. 동기화 대상이 하나일때사용한다
- 교착상태 무엇인가요?
    - 두 프로세스가 서로 종료될때까지 대기하는 프로그램을 실행한다고 생각하자
    - 서로가 종료될때까지 아무 작업을 하지 않기때문에 프로그램이 멈추는 현상을 데드락이라고 한다
- 데드락은 언제 생기나요?
    - 데드락은 다음 4가지 상황을 모두! 만족해야 발생한다 밑에는 예방방법이다
        - Mutual exclusion(상호배제): 한번의 하나의 프로세스만 공유자원 사용가능
            - 공유되는자원을 동시에 사용할 수 있으면 조건을 만족못시킴(데드락발생x)
        - Hold and wait(점유대기): 프로세스 하나가 리소스를 잡고 있고, 다른 자원을 대기중일 때.
            - 한 프로세스가 실행되기 전에 모든 자원을 할당하고 이후엔 다른 프로세스가 자원을 요구하도록! 하면 프로세스 대기를 없앨 수 있음 혹은 자원이 점유되지 않은 상태에서만 자원 요청을 받도록하거나
        - No preemption(비선점): OS가 작동중인 프로세스를 임의로 중단시킬 수 없을 때.
            - 선점허용
        - Circular wait(순환대기): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있을떄
            - 각 프로세스를 선형으로 분류하여 고유번호를 할당하고, 각 프로세스는 현재자신의 자원의 고유번호보다 앞이나 뒤 한쪽 방향으로만 자원을요구하도록 한다
- 데드락이 발생하지 않으려면 어떻게 해야하나요?
    1. 데드락 예방
        - 데드락 발생 조건중 하나를 만족시키지 않음으로써 데드락이 발생하지 않도록하는 것이다
        - 성능을떨어뜨릴 수도 있다
    2. 데드락 피하기
        - 데드락이 발생할것같을땐 아예 리소스를 할당하지 않?는것이다
- 논리주소와 물리주소의 차이에 대해 말해
    
    논리주소
    
    - 논리주소는 가상의 주소이다.
    - 논리 주소는 CPU에 의해 프로그램이 실행되고 있을 때 만들어진다
    
    물리주소
    
    - 사용자들은 직접적으로 물리 주소로 접근하지 못하고 대응되는 논리 주소로 접근한다.
    - 프로그램들은 논리 주소를 생성하고 해당 프로그램이 이 논리 주소에서 실행되고 있다고 가정한다.
    - 그러나 프로그램이 실행되기 위해서는 물리 주소가 필요하다.
    - 그러므로 MMU가 논리 주소가 사용되기 전에 논리 주소와 물리 주소를 대응mapping시킨다.
- MMU란?
    - memory management unit
    - CPU코어 안에 탑재되어 가상 주소를 실제 메모리 주소로 변환해주는 장치
- 왜 논리주소가 필요할까?
    1. 논리주소를 사용하면 프로세스간 격리 가능
        - mmu를 사용해서 논리주소->물리주소로 변환하게 되는데 이때 프로세스가 지정된 논리 주소 공간 외부의 메모리에 직접 액세스하는 것을 막는 과정이 추가로 들어감.
        프로세스별로 물리공간이 추가로 할당되기때문에 프로세스가 지정된 공간만을 참조할 수 있다는것은 프로세스별 메모리 격리가 이루어진다는 의미임
    2. 논리주소를 사용하면 가상메모리를 사용할 수 있게된다
- Demand Paging이 무엇인가요?
    
    현재 필요한 page만 메모리에 올리는 것을 Demand Paging
    
    - 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두는 것이다. 이를 통해 프로세스 전체가 물리적 메모리에 있는 것 '처럼' 수행되는, 즉 물리적 메모리가 훨씬 많이 있는 것처럼 보이게 된다. → 가상메모리 개
    - 결과적으로 메모리에 작은 양의 주소 공간만 있으면 충분히 프로세스를 수행할 수 있고, 그에 따라 더 많은 프로그램을 동시에 실행할 수 있게 된다.
    - 이처럼 현재 필요한 page만 메모리에 올리는 것을 Demand Paging이라고 한다.
- swap out과 swapin의 차이
    - swap out: 디스크로 내보내는것(오래걸림)
    - swap in: 메모리로 들여보내는것
- 단편화(fragmentation)에 대해 설명해보세요
    - 메모리 공간을 사용하지 못하게 되는것
- 외부단편화와 내부 단편화에 대해 설명해보세요
    - external fragmentation
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4018f91c-5746-4578-801a-8b56a655fca1/Untitled.png)
        
        - 30, 60, 20, 40, 60 의 block이라고 가정해볼때
        - 실제 메모리 공간은 120k가 비어있지만 어디에도 70k가 들어갈 수 없다 이러한 상황을 external fragmentation이라고합니다
    - **internal fragmentation**
        - 실제 프로세스 공간보다 큰 메모리를 할당하게 되는 경우를 말합니다
        - 그래서 메모리 공간이 낭비되고 있는 상황을 말합니다 (어떤 프로그램을 os가 4kb을 할당해주었는데 사실상 1kb만 사용되고 있을때 3kb만큼 내부 단편화가 발생하였다고 말합니다)
- segmentation이란?
    - 하나의 프로세스를 여러개로 나누는것을 말합니다
- paging이란?
    - 프로세스를 여러 조각으로 나누는것이다
    - 단순히 크기를 기준으로 나누기때문에 비슷한 요소라도 메모리 공간에 연속적으로 할당되지 않는다
    - **Frame** : 물리 메모리를 일정된 한 크기로 나눈 블록
    - **Page** : 가상 메모리를 일정된 한 크기로 나눈 블록
    - frame을 작게 나눌 수록 fragment(단편화)가 적게 생기고 external fragmentation은 거의 안생긴다
    - logical address → physical address로 변환하는 page table이 필요하다
    - page table은 메모리에 저장되어있다
    - PTBR(page table base register)이 page table을 가리키고
    - PTLR(page table length registaer)이 page table의 크기를 가지고있다
    - → 매번 데이터에 접근할때마다 한번은 데이터에 한번은 page table에 접근해야해서 비효율적이다 → 캐시를 사용한다
    - TLB(tranlation loock-aside buffer): 참조했던 페이지를 담아두는 캐시 역할
    - cpu는 page table보다 TLB를 우선적으로 참조
    - hit ratio: page number가 TLB에서 발견되는 비율
- segmentation vs paging의 차이
    
    
- 연속 메모리 기법에는 동적분할, 고정분할로 나뉘는데 이에 대해 설명 ㄱ ㄱ
    - 연속 메모리 기법은 프로그램 전체가 연속된 공간을 차지해야함
    - 고정분할
        - 각 분할이 모두 같은 크기를 가지고 분할됨 → 이때문에 내부파편화가 일어날 수 잇음
    - 동적분할
        - 그 프로세스에 맞는 가장 작은 크기를 할당 → 외부파편화가 일어날 수 있음
        (내부파편화는감소)
- 불연속 메모리 기법에는 뭐가있나요
    - 불연속 메모리 기법이란, 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법을 말함
    - 페이징: 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식
    - segment: 프로그램을 segment라는 가변 크기로/논리적 내용을 기반으로 나누는 기법(code, data, stack으로 나눔)
        - 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리에 할당
        - 각 세그먼트는 연속적인 공간에 저장, 근데 이 세그먼트모두가 연속적인 공간에 저장되는게 아님.
    - Paging은 내부 단편화 발생 가능, Segmentation은 외부 단편화 발생 가능
- 페이징은 내부/외부 단편화 둘다 발생할까요?
    - 메모리를 고정된 사이즈로 나누고 그 공간을 불연속적으로 할당할수있게 하는게 페이징이니까 외부단편화는 발생하지않을것같아요
    - 고정된 크기로 나눈다는거자체가 필연적으로 내부단편화를 발생시킬거라고 생각했어요
 
# 스프링
- 웹서버와 웹애플리케이션서버의 차이에 대해 설명해주세요
    - 웹서버는 정적리소스를 생성할 수 있는 서버를 말하고,
    - 웹애플리케이션 서버는 정적인 리소스와 동적인 리소스를 모두 제공할 수 있는 서버를 의미합니다
- RequestBody, RequestParam, ModelAttribute의 차이가 뭔가요?
    - RequestBody는 클라이언트가 전송하는 json형태의 http body내용을 MessageConverter를 통해 java object로 변환시켜줍니다
        - 값을 주입하는것이 아니라 리플렉션을 사용해 할당시키기때문에 생성자, getter, setter가 없어도 정상적으로 할당됩니다
    - requestParam은 http 요청 파라미터를 받기 위해 사용합니다
    - modelAttibute는 http body내용과 http parameter 값들을 생성자, getter, setter를 통해 주입하기 위해 사용합니다
        - 기본 생성자가 확인되면 우선 인스턴스(객체)를 생성하고, setter 메서드를 통한 바인딩을 시도한다.
        - 그렇지 않을 경우 필드에 맞는 파라미터를 가진 생성자를 찾아 바인딩을 시도했다.
            - 기본생성자가 있을때만 setter가 필요!
        - [ModelAttribute는 생성자,setter가 필수인가?](https://hyeon9mak.github.io/model-attribute-without-setter/)
- Spring mvc에 대해 설명해주세요
    - Model, view, Controller의 약자입니다
    - model: 데이터관리, 비즈니스 로직을 처리하는 부분
    - view: 유저인터페이스가 표현되는 곳
    - controller: 사용자의 요청을 처리하고 model과 view를 중개하는 역할을합니다
        
        model과 view가 연결되어있지 않으니 적절히 연결을 해줍니다
        
- Springboot와 Spring의 차이
    - 가장 큰 차이점은 Auto Configuration의 차이인 것 같습니다. Spring은 프로젝트 초기에 다양한 환경설정(xml파일이나 config파일)을 해야 하지만, Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 돕습니다
- 스프링에서 빈을 등록하는 방법을 알려주세요
    
    **1.** @Component 어노테이션을 사용하면 빈으로 등록이됩니다.
    
    **2.** 설정 클래스를 따로 만들어 @Configuration 어노테이션을 붙이고,
    
    해당 클래스 안에서 빈으로 등록할 메소드를 만들어 @Bean 어노테이션을 붙여주고 리턴해주면 됩니다.
    
- ioc에 대해 설명해주세요
    - “제어의 역전”
    - 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다. 일반적으로는 개발자가 작성한 코드의 흐름의 제어권이 개발자에게 있습니다. 보통 필요한 객체를 그 객체를 사용하는 클래스에서 생성하죠. 그런데 ioc는 개발자가 생성하지 않고 프레임워크가 생성해주는것을 말해요.
- Spring Framework에 대해 설명해주세요
    - 자바의 다형성을 적극적으로 활용할 수 있는 프레임워크입니다.
    - 제어의역전(객체나 메서드의 호출의 권한이 개발자가 아닌 외부에 있는것)이라는 기술을 통해 애플리케이션의 느슨한 결합을 하게 한다. 왜냐하면 ioc를 사용하면 의존성을 외부에서 주입받게되고, 주입하는 객체가 변경되어도 외부에서 주입받는것이니 해당 객체를 사용하는 클래스 내부 코드를 변경하지 않아도 되기 때문이다.
    - 스프링은 의존성주입을 지원합니다. 의존성이 존재할 경우 스프링이 서로 연결해켜줍니다.
    - 관점지향프로그래밍 즉, aop를 지원합니다. 여러곳에서 사용되는 공통기능을 분리해서 관리할 수 있습니다.
    
- 서블릿이란 무엇인가요?
    - 동적인 웹페이지를 만드는데 필요한 기술이며 response, request를 활용해서 개발자가 쉽게 요청정보에 대해 접근하고 응답정보를 만들 수 있도록 도와줍니다
- 스코프 프로토 타입 빈에 대해 설명해주세요
    - 싱글톤과 반대되는 개념으로, 요청시마다 객체를 생성하는 빈을 의미합니다
- 스프링빈의 라이프사이클에 대해 말해주세요
    
    스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 
    
    → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료
    
    - 초기화 콜백메서드가 왜호출되는가?
        - bean이 생성되고 나서 사용되기전에 필요할 수 있는 추가 설정들을 수행하기 위해서 초기화 콜백메서드가 수행된다 @PostConstuct주석을 넣어주면 초기화시에 해당 메서드가 호출된다

- mvc는 어떠한 흐름으로 요청을 처리하는지 설명해주세요
    
    **DispatcherServlet** : 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제한다.
    
    **HandlerMapping** : 클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정한다.
    
    **HandlerAdapter :** HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을 한다.
    
    **ViewResolver** : Controller의 처리 결과(데이터)를 생성할 view를 결정한다.
    
    1. 클라이언트는 URL을 통해 요청을 전송한다.
    
    2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
    
    3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
    
    4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
    
    5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
    
    6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
    
    7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
    
    8. 데이터가 추가된 뷰를 반환한다.
    
- lombok에 대해 설명해주세요
    - 코드를 줄이는데 사용되는 자바라이브러리입니다. 코드의 가독성을 높여줍니다
    - 롬복은 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어냅니다.
    - 이것을 어노테이션 프로세싱이라고 하는데, 어노테이션 프로세싱은 자바 컴파일러가 컴파일 단계에서 어노테이션을 처리하는 기법을 말합니다.
- 서블릿 동작방식에 대해 설명해주세요
    - 사용자가 url을 입력하면 http request가 서블릿 컨테이너로 전송됩니다
    - 서블릿 컨테이너는 요청정보를 분석해서 HttpServletRequest, HttpServletResponse객체를 생성합니다. 그리고 사용자가 요청한 url이 어떤 서블릿에 대한 요청인지를 찾습니다
    그리고 해당 서블릿의 service 메서드를 호출합니다
    응답이 끝나면 HttpServeltRequest, HttpServletResponse객체를 소멸시킵니다
    
    ```sql
    @WebServlet("/welcome")
    public class WelcomeServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest request, HttpServletResponse response)
                throws IOException {
            String name = request.getParameter("name"); // Retrieve a parameter from the request
            response.setContentType("text/html"); // Set the response content type
            response.getWriter().print("<h1>Welcome, " + name + "!</h1>"); // Write the response
        }
    }
    ```
    
- 스프링의 싱글톤에 대해 설명해주세요
    - 스프링은 스프링빈에 대해 싱글톤패턴을 적용시킵니다. 이를 통해 요청이 들어올떄마다 매번 객체를 만드는것이 아닌, 하나의 객체를 사용해서 여러요청을 처리해서 효율적인 처리가 가능해집니다.
    - 싱글톤 빈은 미리 초기화되고 캐시될 수 있으므로 빈에 액세스할 때 성능이 향상됩니다.

- JDBC에 대해 설명해주세요
    - Java 프로그램에서 데이터베이스와의 상호 작용을 가능하게 하는 API.
    - JDBC는 SQL을 사용하여 데이터를 쿼리하고, 업데이트할 수 있게 해준다.
- 동기 비동기 차이가뭐야?
    - 둘다 프로그래밍에서의 동작 방식을 나타냅니다
    - 동기적인 프로그래밍은 특정 작업이 끝날 때까지 프로그램이 대기하게 된다.
    - 비동기적인 프로그래밍은 특정 작업이 완료되기 전에 프로그램이 다음 작업으로 넘어갈 수 있다
    - 비동기적인 프로그래밍을 하게되면 응답속도가 빠르고 대기시간을 줄일 수 있다는 장점이 있다
    - 동기적인 프로그래밍은 구현이 단순하다는 장점이 있지만 작업이 느릴경우 시스템 전체가 멈추게 돼서 다음 작업이 지연될 수 있다는 단점이 있다
    - 실시간처리가 필요하다면 비동기를 배치처리(대량의 데이터나 작업을 한꺼번에 처리)같은 경우엔 동기처리를 한다
- 필터와 인터셉터의 차이에 대해 설명해주세요
    - 디스패처 서블릿(Dispatcher Servlet)에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공한다.
        - 디스패처 서블릿은 스프링의 가장 앞단에 존재하는 프론트 컨트롤러이므로, 필터는 스프링 범위 밖에서 처리가 되는 것이다.
    - 인터셉터는 Spring이 제공하는 기술로써, 디스패처 서블릿(Dispatcher Servlet)이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다. 즉, 웹 컨테이너(서블릿 컨테이너)에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작을 하는 것이다.
    
- annotation에 대해 설명해주세요
    - 코드에 대한 추가 정보를 제공하는 일종의 메타데이터이다
    - 특별한 의미를 부여하거나 특별한 기능을 수행하게 하는 기술이다
- Controller와 RestController의 차이
    - @Controller는 주로 View를 반환하기 위해 사용합니다. 뷰리졸버를 통해 View를 찾아 랜더링합니다.
    - 데이터를 반환하고 싶으면 @ResponseBody 어노테이션을 활용하여 Json 형태로 데이터를 반환할 수 있습니다.
    - @RestController는 2개의 어노테이션이 합친 것으로, json형태로 객체 데이터를 반환해줍니다.
- DisfetcherServlet에 대해 설명해주세요
    - 디스패처 서블릿은 HTTP 프로토콜로 들어오는 요청을 가장 먼저 받아서 적합한 컨트롤러에게 전달해주는 프론트 컨트롤러입니다.
    - 디스패처 서블릿을 사용하게 되면 공통작업을 코드 중복없이 처리할 수 있습니다.
    
- @Controller, @Repository, @Service의 차이를 설명해주세요
    - @Controller는 클라이언트의 요청을 받고 view를 반환합니다.
    - @Service는 비즈니스 로직을 처리합니다.
    - @Repository는 DB관리 및 DB CRUD 작업을 처리합니다.
    - 이러한 어노테이션을 통해 스프링 관련 작업 예외를 알려줄 수 있게 됩니다.
    
- BeanFactory와 ApplicationContext의 차이점은 무엇입니까?
    - BeanFactory는 빈을 관리하는 ioc 컨테이너를 의미합니다 그리고 이 빈 팩토리에 여러 부가기능들이 들어있는게 **ApplicationContext입니다**
- @SpringBootApplication이란무엇인가요?
    - 스프링 부트로 프로젝트를 실행할때 Application클래스를 만듭니다.
    - @SpringBootApplication는 Application 클래스에 쓰는 어노테이션입니다.
    - 이 어노테이션으로 인해 스프링 부트의 Bean을 읽어와서 자동으로 등록(생성)해줍니다.
    - 어노테이션안의 @ComponentScan을 통해 @Component 가 선언된 Bean을 등록.
    - SpringApplication.run()을 통해 해당 클래스를 run하면, 내장 WAS를 실행시킵니다.
- pathvariable, requestparam의 차이
    - 둘다 url parameter를 가져오는데 사용되지만
    - pathVariable은 값을 하나만 받아올 수 있고, requestparam은 값을 여러개 받아올 수 있습니다
    - requestparam만 default값을 지원합니다
    - 그리고 둘이 정보를 받아오는데서 약간의 차이가 있는데요 pathvariable은 id = ? < 이런식이 아니라 그냥 ? 식으로 입력이 들어와요
 
# 자료구조
- Array와 LinkedList의 차이에 대해 설명해주세요
    1. **데이터 접근에서 차이가 납니다**
        - 배열은 인덱스를 사용하여 빠르게 접근하므로 시간 복잡도는 O(1)이다.
        - LinkedList는 특정 원소에 접근하기 위해서는 처음부터 순차적으로 검색하기 때문에 시간 복잡도는 O(N)이다.
    2. **데이터 삭제/추가에서 차이가 납니다**
        - 배열: 데이터 삽입의 경우 이후의 데이터를 Shift해야 하므로 추가 과정과 시간이 소요된다. O(N)의 시간이 걸린다.
        - LinkedList:
            - 맨 앞과 맨 뒤에만 삽입한다면 O(1)의 시간 복잡도를 갖는다.
            - 그렇지 않다면 삽입할 위치를 찾고(O(N))과 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다.
            - 그럼에도 불구하고 Array보다 빠른 성능을 갖는다.
                - Array의 경우, 데이터를 삽입하여 모든 공간이 꽉 차게 되면 새로운 메모리 공간을 할당받아 옮겨야 하지만, LinkedList를 그럴 필요가 없다. 추가할 때마다 동적으로 메모리 공간을 할당받는다.
    3. **캐시 측면에서 다른 이점을 보입니다**
        - 배열: 요소는 인접한 메모리 위치에 저장되므로 액세스 패턴은 캐시 지역성의 이점을 더 잘 활용하여 일부 시나리오에서 더 빠른 액세스 시간으로 이어집니다.
        - LinkedList: 요소가 메모리 전체에 흩어져 있으므로 캐시 지역성이 도움이 될 가능성이 적습니다.
    4. **메모리할당방식에도 차이가 있습니다**
        - Array
            - 메모리에는 배열이 선언되자 마자 Compile time에 할당되어 진다.
            - 정적 메모리 할당이라고 한다.
        - LinkedList
            - 메모리는 새로운 Node가 추가될 때 runtime에 할당되어 진다.
            - 동적 메모리 할당이라고 한다.
- 언제 배열을, 언제 LinkedList를쓰는게 좋을까요?
    - 삽입과 삭제가 빈번하게 일어난다면 LinkedList를 사용하는 것이 좋다.
    - 데이터에 접근하는 것이 빈번하게 일어난다면 Array를 사용하는 것이 좋다.
- 해시함수에 대해 설명해주세요
    - 해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다.
    - 해시함수는 기본적으로 각각의 키에 대해 모두 다른 해시값을 가집니다. 만약 다른 키에 대래 해시값이 중복된다면, 이를 해시 충돌(Collision)이라고 합니다.
    - 해시함수에 의해 얻어지는 값을 해시코드, 해시라고 한다
- 해싱이란?
    - 해시 함수를 수행하기 전의 원래의 데이터를 `키 (key)`, 해시 함수를 수행한 결과값을 `해시 값 (hash value)`라고 합니다. 그리고 이렇게 `키`를 `해시 값`으로 매핑하는 전체적인 과정을 `해싱 (Hashing)`이라고 합니다.
- 해시함수는 고정된 길이를 사용하는데.. 이때 고정된길이를 어떻게 구해?
    - 해시 함수가 32비트 해시 값을 생성하는 경우 고정 길이는 32비트이고
- 해시 테이블이란?
    - 키와 값을 매핑해둔 데이터 구조이다. 해시 함수로 얻은 해시를 키로 활용하여 index로 사용하고 해당 index에 데이터를 저장하여 효율적인 검색을 위해 사용된다.
    - key에 대한 데이타를 찾을때, hash_function을 한번만 수행하면 array내에 저장된 index 위치를 찾아낼 수 있다.
    - 동기화를 지원한다(두개의 스레드가 한개의 메소드를 동시에 접근할수 없게 지원)
    - key, value에 널 값을 허용하지 않는다.
- 해시테이블은 어떻게 o(1)로 찾을 수 있는거야?
    - key를 해쉬 function에 넣어서 index를 얻고 이 index과 value는 배열의 형태로 저장되어있기땜누에 index로 value를 얻는게 o(1)에가능하다
- 해시를 사용할때의 충돌을 어떻게 해결할까? 방법을 말해보세요
    1. `Separate Chaining`
        
        - Key에 대한 index가 가리키는 자료구조를 LinkedList를 이용하는 방식이다.
        - index로 인해서 충돌이 발생하면 그 index가 가리키고 있는 LinkedList에 노드를 추가한다.
        - key는 여전히 중복되지않은데 index가 중복될 수 있다. 이 경우에 인덱스가 중복돼도 linkedlist를 순회하면서 올바른 key를 찾고 찾으면 올바른 value를 반환한다.
        - 데이터를 검색할 때, 선형 탐색을 하기 때문에 느리다는 단점이 있다.
            - 시간 복잡도 : O(N)
        - LinkedList 대신 트리를 이용하면 성능을 개선시킬 수 있다.
        - JDK 1.8의 경우 index에 노드가 8개 이하인 경우에는 LinkedList를 사용하고 8개를 넘어갈 경우에는 트리 구조로 데이터 저장 구조를 바꾸도록 설계되어 있다.
    2. `Open Addressing`
        - 해시 충돌이 발생하면 해시 함수로 얻은 주소가 아닌 다른 주소 공간에 데이터를 저장하는 방식이다. (해당 키 값에 데이터가 저장되어 있다면 다음 주소에 저장.)
        - 선형 탐사(Linear Probing)
            - 현재 주소에서 고정 크기(ex.1)만큼 다음 주소로 이동하여 데이터를 저장한다.
        - 제곱 탐사(Quadratic Probing)
            - 고정 크기만큼 이동하는 것이 아닌 이동 크기가 제곱수로 늘어나는 방식이다. (1,4,9,16...)
        - 이중 해싱(Double Hashing)
            - 해시 충돌 시 다른 해시 함수를 한번 더 적용하는 방식이다.
        - 재해싱(Rehashing)
            - 해시 테이블의 크기를 늘리고, 늘어난 해시 테이블의 크기에 맞추어 모든 데이터를 다시 해싱하는 방식이다.
        
        이러한 Open Addressing의 단점은 삭제가 어렵다는 것인데, 삭제를 했을 경우 충돌에 의해서 뒤로 저장된 데이타는 검색이 안될 수 있다. 아래에서 좌측 그림을 보자,  2번 index를 삭제했을때, key 11에 대해서 검색하면, index가 1이기 때문에 1부터 검색을 시작하지만 앞에서 2번 index가 삭제되었기 때문에, 2번 index까지만 검색이 진행되고 정작 데이타가 들어 있는 3번 index까지 검색이 진행되지 않는다.
        
        그래서 이런 문제를 방지하기 위해서 우측과 같이 데이타를 삭제한 후에, Dummy node를 삽입한다. 이 Dummy node는 실제 값을 가지지 않지만, 검색할때 다음 Index까지 검색을 연결해주는 역할을 한다.
        
        ( 각 row는 linkedlist형태가 아니기떄문에 1→3번을 가리키게는 못한다. )
        
        Open Addressing은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비하여 캐시 효율이 높다. 따라서 데이터 개수가 충분히 적다면 Open Addressing이 Separate Chaining보다 더 성능이 좋다. 하지만 배열의 크기가 커질수록(M 값이 커질수록) 캐시 효율이라는 Open Addressing의 장점은 사라진다. 배열의 크기가 커지면, L1, L2 캐시 적중률(hit ratio)이 낮아지기 때문이다.
        
- 해시테이블에서 삽입, 조회의 시간복잡도
    - 여기서 n은 테이블의 요소 수 이다
    - 삽입, 검색시 collision의 발생 여부와 어떤 알고리즘을 써서 collision을 해결하는지에 따라 시간복잡도가 달라집니다
    - 삽입: o(1)
        - collision발생시
            - `Separate Chaining` 에서는 보통 o(1)이지만 만약 링크드 리스트의 가장 꼬리에 연결하려면.. 모든 요소를 거쳐야 끝으로 갈 수 있어서 o(n)이 된다  (head에 저장할 경우 o(1)이 걸리겠죠)
            - `Open Addressing` 보통은 o(1)이지만 테이블이 가득 차서 열린슬롯을 찾는데 시간이 걸리면 최대 o(n)의 시간이 걸린다
    - 검색: o(1),
        - collision이 발생시
            - `Separate Chaining` 에서는 o(n) - linkedlist를 다 도는데 걸리는 시간
            - `Open Addressing` 에서는 보통은 o(1)이 걸리지만 모든 키가 충돌나거나하면 o(n)이 된다
                - "모든 키 충돌"이라고 하면 해시 함수가 모든 키를 해시 테이블의 동일한 인덱스에 매핑한다는 의미
- 해시테이블의 단점
    - 데이터가 많아지면 collision이 발생한다
    - collision이란 다른 key값에 대해 동일한 value가 반환되는 현상을 말한다
- 해시테이블도 단점이 있는데도 왜 해시를 사용하는걸까?
    - 효율적으로 검색이 가능하기 때문이다
    - 언제나 동일한 해시 값을 리턴을 하기 때문에 index를 알면 o(l)만에 빠른 검색이 가능해진다.
- HashMap 과 HashTable의 차이
    - HashMap : Map 인터페이스를 구현하기 위해 HashTable을 사용한 클래스로 key와 value에 Null이 허용된다. 동기화를 지원하지 않는다.
    - HashTable : HashMap보다 속도는 느리지만, 동기화를 지원하며 key와 value에 null이 허용되지 않는다.
- 좋은 해쉬 함수란?
    - 좋은 해쉬 함수란, 데이타를 되도록이면 고르게 분포하여, 충돌을 최소화할 수 있는 함수이다.
    - 예를들어 공간이 남아있는데도 충돌이 나는 경우는 좋은 해쉬함수가 아니다.
    - 최대한 공간을 잘 활용해서 남은 공간을 모두 데이터를 저장할수있게 만들어서 충돌을 최소화하는게 좋은 해쉬 함수다
- seperate chaning vs open addressing에서 충돌이 발생했을시에 이론상 영원히 데이터 추가하는게 가능해?
    - seperate chaing은 시스템이 사용하는 메모리 공간내에 동적할당을 해서 만드는데에 반해 -
    - open addressing은 내가 가진 해쉬테이블 즉 배열 의 길이에 제한돼서 할당을 하는방식이다. 그래서 배열이 꽉차면 다시 크기를 변경해서 값을 복사하는 과정을 거쳐야한다. 그래서 후자는 불가능하고 전자라면 어느정도 가능하다
- 어쨋든 hash table은 배열인데 value를 어떻게 삭제해?
    - 그러니까 각각의 요소는 linkedlist로 연결되어있지않은데 어떻게 중간값을 삭제하는게 가능하냐는 얘기야 shift연산이라든지 뭐가잇어야할것같은데 말이다
    - 요소가 참조하는 연결리스트의 값을 삭제한다 요소자체가 삭제되는게 아니라..
    
    [https://velog.io/@flre_fly/hash-table-중간-value-삭제](https://velog.io/@flre_fly/hash-table-%EC%A4%91%EA%B0%84-value-%EC%82%AD%EC%A0%9C)
    
- equals는정의하고 hashcode는 정의안하면 어떻게 돼?
    - hash비교가 안됨
    - 즉, 같은 key값에 대해 동등성비교를 안한다거나.. 제대로 비교를 안함
- ArrayList와 LinkedList의 차이
    - ArrayList
        - 내부적으로 배열을 사용하여 데이터를 관리
        - 인덱스를 가지고 있어 데이터 검색에 적합하고 속도가 빠르다.
            - 시간 복잡도 : O(1)
        - 데이터의 삽입, 삭제 시 해당 데이터를 제외한 모든 데이터를 **임시 배열을 생성**해 복사하므로 삽입, 삭제가 빈번할 경우 속도가 느리며 부적합하다.
            - 시간 복잡도 : O(n)
        - 동기화를 지원하지 않아 Vector보다 빠르다.
    - LinkedList
        - 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 오래 걸리며 성능상 좋지 않다.
            - 시간 복잡도 : O(n)
        - 데이터의 삽입, 삭제시 불필요한 데이터의 복사가 없어 데이터의 삽입, 삭제 시 유리하다.
            - 시간 복잡도 : O(1)
            - 하지만, 경우에 따라서 다르기도 하다.
            - 왜냐하면 삽입, 삭제를 하기 위한 노드를 찾기 위해서는 결국 O(n)이 걸리고 삽입, 삭제를 위한 시간 복잡도까지 계산하면 결국 O(n)이 걸린다.
            - 만약, 중간 요소의 삽입, 삭제가 없고 맨 앞과 뒤 요소의 삽입, 삭제만 한다면 O(1)이 걸린다. 그렇지 않으면 O(n).
- 큐와 스택의 시간복잡도/공간복잡도
    - Stack
        - 나중에 들어간 원소가 먼저 나오는 구조이다.
        - 조회 시간 복잡도 : O(n)
        - 삽입 시간 복잡도: O(1)
        - 공간 복잡도 : O(n)
    - Queue
        - 먼저 들어간 원소가 먼저 나오는 구조이다.
        - 조회 시간 복잡도 : O(n)
        - 삽입 시간복잡도 O(1)
        - 공간 복잡도 : O(n)
- 힙의 삽입, 삭제시 시간복잡도/공간복잡도
    - 삽입 : O(logN)
    - 삭제 : O(logN)
    - 공간복잡도: O(N)
- 힙에서의 부모 자식간의 관계를 수치화 해서 말해보세요
    
    <부모 노드와 자식 노드의 관계>
    
    - 왼쪽 자식 index : (부모 index) * 2
    - 오른쪽 자식 index : (부모 index) * 2 + 1
    - 부모 index : (자식 index) / 2
- 힙의 삽입을 구현해보세요
    1. <힙의 삽입>
    - 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입.
    - 새로운 노드를 검사해서 부모 노드와 교환한다.
        
        ```java
        void insert_max_heap(int x){
          maxHeap[++heapSize] = x;
          // 힙 크기를 하나 증가시키고, 마지막 노드에 x를 삽입.
          
          for(int i=heapSize; i>1; i--){
            // 마지막 노드가 자신의 부모 노드보다 크면 swap
            if(maxHeap[i / 2] < maxHeap[i]){
              swap(i / 2, i);
            } else {
              break
            }
          }
        }
        ```
        
- 힙 삭제를 구현해보세요
    1. <힙의 삭제>
    - 최대 힙에서 최대값은 루트 노드이므로 루트 노드가 삭제된다. (최대 힙에서 삭제 연산은 최대값 요소를 삭제하는 것이다.
    - 힙의 마지막 노드를 루트로 이동시킨다
    - 힙을 재구성 한다.
    
    ```java
    int delete_map_heap(){
      if(heapSize == 0) return 0; // 비어있음을 의미하므로 리턴.
      
      int root = maxHeap[1]; // 루트 노드의 값을 저장.
      maxHeap[1] = maxHeap[heapSize]; // 마지막 노드를 루트 노드로 이동.
      maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드를 0으로 초기화.
      
      // 힙을 구현하는 배열을 정렬하는 부분.
      for(int i=1; i*2 <= heapSize;){
        // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 끝. 
        if(maxHeap[i] > maxHeap[i * 2] && maxHeap[i] > maxHeap[i * 2 + 1]){
          break;
          // 왼쪽 노드가 더 큰 경우, swap
        } else if(maxHeap[i * 2] > maxHeap[i * 2 + 1]){
          swap(i, i * 2);
          i = i * 2;
          // 오른쪽 노드가 더 큰 경우, swap
        } else {
          swap(i, i * 2 + 1);
          i = i * 2 + 1;
        }
      }
      
      return root;
    }
    ```
    
- 트리의 장점
    - 일반 배열에서 삽입이나 삭제를 하는데 O(N)의 시간이 걸린다.
    - 배열의 첫번째 원소에 삽입하는 경우 나머지 모든 요소들을 한 칸씩 뒤로 미뤄야 하므로 최악의 시간 복잡도 O(N)이 나온다.
    - 하지만, 트리는 편향 트리가 아닌 이상 일반적인 트리에서는 O(log N) 정도의 시간으로 줄여진다.
    - 또한 트리는 계층 구조를 이루는 경우에 굉장히 좋다.
- 트리의 특징
    - Tree는 Stack이나 Queue와 같이 선형 구조가 아닌 비선형 자료구조이다.
    - 계층적 관계를 표현한다.
    - 루트 노드를 제외한 모든 노드는 단 하나의 부모 노드만을 갖는다.
- 터미널 노드란?
    
    자식 없는 노드
    
- 단말노드란?
    - 자식 없는 노드
- 인터널 노드란?
    - Internal Node : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.
- 이진트리란?
    - 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 진다. (노드가 없을 수도 있다.) 나뉘어진 두 서브 트리도 모두 이진 트리어야 한다.
- 이진트리의 종류
    
    - 각 층별로 숫자를 매겨서 이를 트리의 레벨이라고 한다. 레벨은 1부터 시작하고 루트 노드의 레벨은 1이다. 트리의 최고 레벨을 가리켜 트리의 높이라고 한다.
    - 종류
        - **Full Binary Tree(포화 이진 트리)** : 모든 레벨이 꽉 찬 이진 트리를 의미한다.
        - **Complete Binary Tree(완전 이진 트리)** : 왼쪽에서 오른쪽으로 순서대로 차곡 차곡 채워진 이진 트리를 의미한다.
- 이진탐색트리(**BST(Binary Search Tree)**)란?
    
    **이진 탐색 트리의 목적은?**
    
    - 이진 탐색 + 연결 리스트
    - 이진 탐색
        - **탐색에 소요되는 시간 복잡도는 O(logN)**
        - 하지만 삽입, 삭제가 불가능.
    - 연결 리스트
        - **삽입, 삭제의 시간 복잡도는 O(1)**
        - 하지만 탐색하는 시간 복잡도는 O(N)
    - 이 두 가지를 합하여 장점을 모두 얻기 위해 고안된 것이 `이진 탐색 트리`
    - 즉, 효율적인 탐색 능력을 가지고 자료의 삽입, 삭제도 가능하게 만드는 것이다.
- 이진트리/이진탐색트리의 정의
    - 이진트리
        - 각 노드의 자식 노드가 최대 2개인 트리
    - 이진탐색트리
        - 각 노드에 중복되지 않는 키(key)가 있다.
        - 왼쪽 서브 트리는 해당 노드보다 작아야하고 오른쪽 서브크리는 해당 노드보다 커야한다
        - 좌우 서브 트리도 모두 이진 탐색 트리여야 한다.
- 이진트리의 순회방법
    1. 전위 순회(Pre Order) : 루트 -> 왼쪽 -> 오른쪽
    2. 중위 순회(In Order) : 왼쪽 -> 루트 -> 오른쪽
    3. 후위 순회(Post Order) : 왼쪽 -> 오른쪽 -> 루트
 



---
참고
https://github.com/WooVictory/Ready-For-Tech-Interview
